1.请将下列无符号数据在不同的进制表达间进行转换。
(1) 二进制转换为十进制：$101011_2、001101_2、01011010_2、0000111010000101_2。$
(2) 十进制转换为二进制：$42_{10}、79_{10}、811_{10}、374_{10}。$
(3) 十六进制转换为十进制：$8AE_{16}、C18D_{16}、B379_{16}、100_{16}。$
(4) 十进制转换为十六进制：$81783_{10}、1922_{10}、345208_{10}、5756_{10}。$
答：
(1) 43，13，90，3717
(2) 101010，1001111，1100101011，101110110
(3) 2222，49549，45945，256
(4) 13F77，782，54478，167C

2.请给出 32 位二进制数分别视作无符号数、原码、补码时所表示的数的范围。
答：
无符号数：$0\sim 2^{32}-1$
原码：$-(2^{31}-1)\sim 2^{31}-1$
补码：$-2^{31}\sim 2^{31}-1$

3.请将下列十进制数表示为 8 位原码和 8 位补码，或者表明该数据会溢出：
$45_{10}、- 59_{10}、-128_{10}、119_{10}、127_{10}、128_{10}、0、-1_{10}。$
答：

|十进制数|8位原码|8位补码|
|---|---|---|
|$45_{10}$|0010 1101|0010 1101|
|$-59_{10}$|1011 1011|1100 0101|
|$-128_{10}$|溢出|1000 0000|
|$119_{10}$|0111 0111|0111 0111|
|$127_{10}$|0111 1111|0111 1111|
|$128_{10}$|溢出|溢出|
|$0_{10}$|0000 0000/1000 0000|0000 0000|
|$-1_{10}$|1000 0001|1111 1111|

$-128_{10}$：8位原码表示范围为 $-(2^7-1)\sim 2^7-1$，即-127~127，故溢出。
$128_{10}$：8位原码表示范围为-127~127，8位补码表示范围为-128~127，故原码补码均溢出。

>0的原码有正0和负0两种。

4.请将下列数据分别视作原码和补码，从 8 位扩展为 16 位：
$00101100_2、11010100_2、10000001_2、00010111_2 。$
答：

|原8位数|16位原码|16位补码|
|---|---|---|
|0010 1100|0000 0000 0010 1100|0000 0000 0010 1100|
|1101 0100|1000 0000 0101 0100|1111 1111 1101 0100|
|1000 0001|1000 0000 0000 0001|1111 1111 1000 0001|
|0001 0111|0000 0000 0001 0111|0000 0000 0001 0111|

>原码的扩展：符号位放在最高位，中间全部补0。
>补码的扩展：补符号位。

5.请将下列浮点数在不同进制间进行转换。
(1) 十进制数转换为单精度数：0、116. 25、-4. 375。
(2) 十进制数转换为双精度数：-0、116. 25、-2049. 5。
(3) 单精度数转换为十进制数：0xff800000、0x7fe00000。
(4) 双精度数转换为十进制数：0x8008000000000000、0x7065020000000000。
答：
(1) 0x0、0x42E88000、0xC08C0000
(2) 0x8000000000000000、0x405D100000000000、0xC0A0030000000000
(3) 负无穷、非数
(4) $-2^{-1023}$(非规格化数) 、$2^{775}+2^{773}+2^{771}+2^{764}$

[[../notes/第8章 运算器设计#浮点数]]

6.请写出下图所示晶体管级电路图的真值表，并给出对应的逻辑表达式。
![[Pasted image 20221208105258.png]]
答：

|A|B|C|Y|
|---|---|---|---|
|0|0|0|1|
|0|0|1|1|
|0|1|0|1|
|0|1|1|0|
|1|0|0|1|
|1|0|1|0|
|1|1|0|1|
|1|1|1|0|

$Y=\overline{(A|B)C}$

[[../notes/第8章 运算器设计#8.1.3 CMOS 逻辑电路]]

7.请写出下图所示逻辑门电路图的真值表。
![[Pasted image 20221208105334.png]]
答：

|A|B|C|Y|
|---|---|---|---|
|0|0|0|1|
|0|0|1|1|
|0|1|0|1|
|0|1|1|0|
|1|0|0|1|
|1|0|1|0|
|1|1|0|1|
|1|1|1|0|

8.请用尽可能少的二输入 NAND 门搭建出一个具有二输入 XOR 功能的电路。
答：
![[Pasted image 20221208182627.png]]

9.请用 D 触发器和常见组合逻辑门搭建出一个具有同步复位为 0 功能的触发器的电路。
答：
![[Pasted image 20221208182742.png]]

>同步：有时钟才有复位效果
>复位：R（0有效/1有效）
>为0 ：R有效时输入为0

10.证明 $[X+Y]_补 = [X]_补 + [Y]_补$。
答：
假设X、Y、X+Y都在n位补码表示范围内（无溢出）。
由补码定义，
$[X]_补 = (2^n+X) mod 2^n$，$[Y]_补 = (2^n+Y) mod 2^n$ ，$[X+Y]_补 = (2^n+(X+Y)) mod 2^n$
$[X]_补+[Y]_补$中的+为无符号n位二进制加
$$
\begin{aligned}
故
[X]_补+[Y]_补 
&= ((2^n+X)\pmod{2^n} + (2^n+Y)\pmod{2^n}) \pmod{2^n}\\
&= (2^n+X+2^n+Y) \pmod{2^n}\\
&= (2^n+X+Y) \pmod{2^n}\\
&= [X+Y]_补
\end{aligned}
$$

11.证明 $[X-Y]_补 = [X]_补 + [-Y]_补$。
答：
\[X-Y\]补 = \[X+(-Y)\]补 = \[X\]补+ \[-Y\]补  

12.假设每个 “非门” “与非门” “或非门” 的扇入不超过 4 个且每个门的延迟为 T，请给出下列不同实现的 32 位加法器的延迟。
(1) 行波进位加法器；
(2) 4 位一块且块内并行、块间串行的加法器；
(3) 4 位一块且块内并行、块间并行的加法器。
答：
(1) 2×31+3=65T
(2) 2+2×8+3=21T
(3) 2+2×5+3=15T

[[../notes/第8章 运算器设计#8.2.1 定点补码加法器]]

>(1) n位行波进位加法器：2×(n-1)+3
>
>(2) 4 位一块且块内并行、块间串行的加法器：如果有n位，则有n/4块，延长为2+2×n+3
>但是这里有个问题，书上的加法器存在5输入，[[../notes/第8章 运算器设计#^ca6e2e]]
>题目要求扇入不超过 4 个。所以我们要将其改造成4输入，其实改造后延迟并没有变化，还是2。
>![[Pasted image 20221213140950.png]]
>
>(3) 4 位一块且块内并行、块间并行的加法器：
>2层最多16位，32位需要3层。

13.作为设计者，在什么情况下会使用行波进位加法器而非先行进位加法器？
答：
  
| |优点|缺点|
|---|---|---|
|行波进位|逻辑简单|速度慢|
|先行进位|速度快|逻辑复杂|
所以对速度要求低，对逻辑（面积）要求高时使用行波进位加法器。

[[../notes/第8章 运算器设计#行波进位加法器]] [[../notes/第8章 运算器设计#先行进位加法器]]

14.请利用图 8.21 所示的 4 位先行进位逻辑组建出块内并行且块间并行的 64 位先行进位加法器的进位逻辑，并证明其正确性。
答：
![[Pasted image 20221213151626.png]]
![[Pasted image 20221213151744.png]]

[[../notes/第8章 运算器设计#先行进位加法器]]

15.请举例说明 $[X \times Y]_补 \neq [X]_补 \times [Y]_补$
答：
四位补码 3×(-4)，结果为8位补码
$X=3_{10}=0011_2$
$Y=(-4)_{10}=1100_2$
$[X\times Y]_补 = 11110100_2=-12_{10}$
$[X]_补\times[Y]_补=00100100_2 = 36_{10}$

16.请证明 $[X\times2^n]_补=[X]_补\times2^n$
答：
令X表示为m位补码
$[X\times 2^n]_补$ 	
$= (2^{m+n}+X\times2^n) \pmod{2^{m+n}}$
$= (2^n\times(2^m+X)) \pmod{2^{m+n}}$
$= 2^n\times(2^m+X) \pmod{2^m}$
$= 2^n\times[X]_补$

17.假设每个 “非门” “与非门” “或非门” 的扇入不超过 4 个且每个门的延迟为 T，请给出下列不同实现将 4 个 16 位数相加的延迟：
(1) 使用多个先行进位加法器；
(2) 使用华莱士树及先行进位加法器。
答：
(1) 使用多个先行进位加法器（4位一块）
两层加法器逻辑：(a+b)+(c+d)
16位先行进位加法的延迟：2+2×3+3=11T
两层逻辑的延迟为11×2=22T（第一层分别计算a+b，c+d，第二层计算(a+b)+(c+d)）

(2) 
四个数的华莱士树结构为两级全加器，最长延迟为6T
![[Pasted image 20221213154205.png]]
先行进位两个 16 位数相加，延迟为11T 
总延迟为 6+11=17T

[[../notes/第8章 运算器设计#先行进位加法器]]

18.请系统描述采用两位 Booth 编码和华莱士树的补码乘法器是如何处理 $[-X]_补$ 和 $[-2X]_补$ 的部分积的。
答：
2位Booth编码的N位乘法，需要处理N/2个部分积，包括0、\[X\]补、\[2X\]补、\[-X\]补、\[-2X\]补。
补码负数需要取反加1。
对Booth编码：\[-X\]补按位取反，\[-2X\]补左移一位再按位取反
还剩余N/2个“+1”
华莱士树：Booth的“+1”接入华莱士树的进位输入 (N/2-2个)
对最终加法器：Booth的“+1”接入最终加法器的进位 (1个) 和进位最低位 (1个)

[[../notes/第8章 运算器设计#Booth乘法与华莱士树]]
[[../notes/第8章 运算器设计#^069ae0]]

19.用 Verilog 语言设计一个 32 位输入宽度的定点补码乘法器，要求使用 Booth 两位一乘和华莱士树。
答：
```
module booth(
        input  [ 2:0] y,
        input  [63:0] X,
        output [63:0] P,
        output        c
);

// 选择信号
wire s_,sp,s_2,sp2;
assign s_  = ( y[2] &  y[1] & ~y[0]) | ( y[2] & ~y[1] &  y[0]);  // -X
assign sp  = (~y[2] &  y[1] & ~y[0]) | (~y[2] & ~y[1] &  y[0]);  // +X
assign s_2 = ( y[2] & ~y[1] & ~y[0]);                            // -2X
assign sp2 = (~y[2] &  y[1] &  y[0]);                            // +2X
assign c   = s_ | s_2;                                           // -X和-2X补码需要+1

// 生成部分积
assign P[0] = s_ & ~X[0] | sp & X[0] | s_2;
generate
        genvar i;
        for(i=1;i<64;i=i+1)
        begin: bs
                assign P[i] = s_ & ~X[i] | sp & X[i] | s_2 & ~X[i-1] | sp2 & X[i-1];
        end
endgenerate

endmodule // booth

module wallace(
        input [15:0] n,
        input [13:0] cin,
        output [13:0] cout,
        output c,
        output s
);
// 部分乘积有16个，所以需要设计一个16输入的1位华莱士树。
// 根据下图，例化15个全加器，再连线即可。
wire [13:0] st;
fulladd i0 (.a(   n[15]), .b(   n[14]), .c(   n[13]), .co(cout[ 0]), .s(st[ 0]));
fulladd i1 (.a(   n[12]), .b(   n[11]), .c(   n[10]), .co(cout[ 1]), .s(st[ 1]));
fulladd i2 (.a(   n[ 9]), .b(   n[ 8]), .c(   n[ 7]), .co(cout[ 2]), .s(st[ 2]));
fulladd i3 (.a(   n[ 6]), .b(   n[ 5]), .c(   n[ 4]), .co(cout[ 3]), .s(st[ 3]));
fulladd i4 (.a(   n[ 3]), .b(   n[ 2]), .c(   n[ 1]), .co(cout[ 4]), .s(st[ 4]));

fulladd i5 (.a(  st[ 0]), .b(  st[ 1]), .c(  st[ 2]), .co(cout[ 5]), .s(st[ 5]));
fulladd i6 (.a(  st[ 3]), .b(  st[ 4]), .c(   n[ 0]), .co(cout[ 6]), .s(st[ 6]));
fulladd i7 (.a( cin[ 0]), .b( cin[ 1]), .c( cin[ 2]), .co(cout[ 7]), .s(st[ 7]));
halfadd i8 (.a( cin[ 3]), .b( cin[ 4]),               .co(cout[ 8]), .s(st[ 8]));

fulladd i9 (.a(  st[ 5]), .b(  st[ 6]), .c(  st[ 7]), .co(cout[ 9]), .s(st[ 9]));
fulladd i10(.a(  st[ 8]), .b( cin[ 5]), .c( cin[ 6]), .co(cout[10]), .s(st[10]));

fulladd i11(.a(  st[ 9]), .b(  st[10]), .c( cin[ 7]), .co(cout[11]), .s(st[11]));
fulladd i12(.a( cin[ 8]), .b( cin[ 9]), .c( cin[10]), .co(cout[12]), .s(st[12]));

fulladd i13(.a(  st[11]), .b(  st[12]), .c( cin[11]), .co(cout[13]), .s(st[13]));

fulladd i14(.a(  st[13]), .b( cin[12]), .c( cin[13]), .co(c), .s(s));
endmodule // wallace

module mul(
        input [31:0] a,
        input [31:0] b,
        output [63:0] s
);
// input
wire [63:0] a_ = {{32{a[31]}},a};

// booth (不断例化之前的booth编码，每次例化都要将X和Y移位，得到16个64位的部分积)
wire [63:0] P[15:0];
wire [15:0] C;
                booth bo0_inst(.Y({b[1:0],1'b0}),.X(a_),.P(P[0]),.c(C[0]));
generate
        genvar i;
        for(i=1;i<16;i=i+1)
        begin: bo
                booth inst(.Y(b[i*2+1:(i-1)*2+1]),.X(a_>>(2*i)),.P(P[i]),.c(C[i]));
        end
endgenerate

// switch (将部分积转换为华莱士树的输入)
wire [15:0] PP[63:0];

generate
        genvar i,j;
        for(j=0;j<64;j=j+1)
        begin: sw1
                for(i=0;i<16;i=i+1)
                begin: sw2
                        assign PP[j][i] = P[i][j];
                end
        end
endgenerate

// wallace (将一位华莱士树例化64次再相加)
wire [63:0] cout,sout;
wire [13:0] ct[63:0];
                wallace wa0_inst(.n(PP[0]), .cin(C[13:0]), .cout(ct[0]), .c(cout[0]), .s(sout[0]));
generate
        genvar i;
        for(i=1;i<64;i=i+1)
        begin: wa
                wallace inst(.n(PP[i]), .cin(ct[i-1]), .cout(ct[i]), .c(cout[i]), .s(sout[i]));
        end
endgenerate

// final add (最后将S和C错位相加，并且把之前补码的+1也要加上)
assign s = sout + {cout[62:0],C[14]} + C[15];
endmodule
```

![[Pasted image 20221213160547.png]]

[[../notes/第8章 运算器设计#Booth乘法与华莱士树]]

20.单精度和双精度浮点数能表示无理数 π 吗？为什么?
答：不能。单精度和双精度浮点数只能表示有限小数。

[[../notes/第8章 运算器设计#浮点数]]

>计算机中的数总是有精度的限制。
>只能精确表示精度范围内的有限小数，不能精确表示无限小数。

