#计算机体系结构-性能分析
## 12.1 计算机系统性能评价指标
### 12.1.1 计算机系统常用性能评价指标
##### 计算机系统的性能的衡量指标
执行时间或者响应时间、归一化的执行时间、每条指令的时钟周期数(CPI)、每秒执行百万条指令数(MIPS)、每秒执行百万浮点运算数(MFLOPS)、每秒执行的事务数(TPS)、每秒帧率(FPS)、带宽(MBPS)、主频(MHz)

##### 计算机的性能
本质定义：完成一个任务所需要的时间。
计算机系统完成某个任务所花费的时间称为执行时间，分为墙上时钟时间和系统时间。
计算机中完成一个任务的时间：CPU 计算、磁盘的访问、内存的访问、输入输出的活动和操作系统的开销等所有的时间。 

##### CPU 时间
CPU时间指CPU 计算的时间，而不包括等待 IO 的时间或者执行其他程序的时间。 
CPU 时间能进一步被分为：
1. 用户态 CPU 时间：花在程序执行上的 CPU 时间 
2. 系统态 CPU 时间：花在操作系统上的执行时间。

比较两台机器 (X 和 Y) 的性能
X 的速度是 Y 的 n 倍：Y的执行时间/ X的执行时间 = n
执行时间和性能成反比：X的性能 = 1 / X的执行时间
故 n = Y的执行时间/X 的执行时间 = X 的性能/ Y 的性能

CPU的性能和三个因素有关：
1. 时钟周期  (时钟频率)
2. 每条指令的时钟周期数 (CPI) 
3. 程序的执行指令数 (IC)
$$
CPU_{time}=时钟周期数 \times 时钟周期
=IC \times CPI \times Cycle Time
$$

**指令数**
影响因素
1. 算法
2. 编程语言
3. 编译系统
4. 指令系统架构

**CPI和IPC**
CPI：每条指令的时钟周期数 Clock cycles Per Instruction
IPC：每个时钟周期内所执行的指令数 Instructions Per Clock
计算公式
$$
CPI=\frac{Cycle}{IC}=\sum_{i=1}^n \frac{IC_i}{IC} \times CPI_i
$$

**时钟频率**
时钟频率 (MHz 或 GHz)：CPU 时钟的每秒时钟周期数。 
每台计算机都有一个时钟，运行在一定的频率上，通常称一个时钟周期为一拍 (Cycle)。
影响因素：
1. 工艺技术
2. 微结构：如流水线划分，多发射
3. 逻辑设计：如串行进位加法器和先行进位加法器
4. 物理设计：如动态电路

**MIPS，MFLOPS**
$$
MIPS=\frac{1}{CycleTime * CPI * 10^6}=\frac{主频}{CPI * 10^6}
$$
MIPS：每秒执行百万指令数。
MFLOPS：每秒执行百万个浮点操作。

### 12.1.2 并行系统的性能评价指标
##### 评价指标
1. 可扩展性：指随着并行系统中机器规模的扩大，并行系统的性能随之增长的特性。
2. 加速比 ( Speedup) ：同一个任务在单处理器系统和并行处理器系统中运行所耗费时间的比率。

##### 加速比
$$
SP = T1 / TP
$$
T1：单处理器下的运行时间，TP：在有P 个处理器的并行系统中的运行时间。 

**线性加速比**
SP =P

**超线性加速比**
加速比超过处理器数的情况称为“超线性加速比”。
原因：高速缓存效应。
较之串行计算，在并行计算中，不仅参与计算的处理器数量更多，不同处理器的高速缓存也可集合使用。如果集合的缓存便足以提供计算所需的存储量，算法执行时便不必使用速度较慢的内存，因而存储器读写时间便能大幅降低。

##### 阿姆达尔定律
概念：系统中对**某一部件**采用更快执行方式所能获得的**系统**性能改进程度，取决于这种执行方式被使用的**频率**，或所占总执行时间的比例。
定义了采取增强某部分功能处理的措施后可获得的性能改进或执行时间的加速比。 
$$
s = \frac{1}{(1-a) +\frac{a}{n}}, 
$$
a：并行计算部分所占比例，n：并行处理节点数。 
- 1-a=0 时 (即没有串行，只有并行)，最大加速比 s = n；
- a=0 时 (即只有串行，没有并行)，最小加速比 s = 1；
- n→∞ 时，极限加速比 s→1/(1-a)，这也是加速比的上限。 
例如，若串行代码占整个代码的 25%，则并行处理的总体性能不可能超过 4。 

局限：只在给定问题规模的前提下成立。
如果串行部分并不随着问题规模的增加而增加，那么扩大问题规模时，加速比仍有可能继续增加。

## 12.2 测试程序集
### 12.2.1 微基准测试程序
##### 概念
微测试程序 (microbench) 是一系列很小的测试程序或者代码片段序。
这些测试程序对处理器核的某个模块进行了测试，同时排除了处理器其他模块的影响。
特别适合处理器设计时对某个模块的选择和优化，例如分支预测器模块、执行单元模块和访存流水线模块，这几个模块可以较准确地反映流水线的效率。

##### Sim-Alpha


##### Coremark
CoreMark是一个综合性的基准测试程序，主要用于测量嵌入式系统中 CPU 的性能。
由嵌入式微处理器基准测试协会 (英文简称 EEMBC) 开发，用于取代过时的 Dhrystone 测试程序。 

其代码使用 C 语言编写，主要执行：
1. 列表操作 (列表的插入和删除、 反转列表和排序等)
2. 矩阵运算 (矩阵加、 矩阵常量乘、 矩阵向量乘、 矩阵和矩阵的乘)
3. 简单状态机 (扫描字符串进行状态转换, 主要测试 switch- case 和 if 语句的行为)
4. CRC 运算 (测试循环冗余校验运算和用于测试过程的自检)

优点
1. 代码量很小、可移植性高、很容易理解、免费。
2. CoreMark 程序中的运算所需要的值不会在编译的时候产生，这样就能确保编译器不会在编译时预计算结果，从而减少了编译器优化选项的干扰。
3. CoreMark 没有调用库函数。
4. 测试结果为单一分值，衡量每秒钟执行了多少次迭代，便于不同处理器之间分值的比较。

##### LMbench
LMbench是由HP以色列海法实验室开发的一套微测试程序集，可测量许多和系统性能相关的因素。 
衡量两个关键特征：延迟和带宽。 
1. 带宽：系统中搬运数据的能力。
	如各级 Cache 的带宽、内存的带宽、缓存的 IO 带宽等。
2. 延迟：系统的反馈时间或者开销。
	如各级 Cache 的访问延迟、内存访问的延迟和操作系统中某一项功能的开销，包括信号处理的开销、进程创建的时间、上下文切换的时间、进程间通信的开销、文件系统的延迟和磁盘的延迟等。

##### STREAM
STREAM 基准测试程序测量计算机的可持续内存带宽。 
STREAM 是一个简单的合成测试程序，主要是测量内存的带宽 (MB/ s) 和简单向量核心代码的计算速率。可以分别测量单核带宽和多核带宽。
测试程序由 Copy、Scale、Add和Triad 四部分组成，测试了4个循环，并给出不同的内存带宽峰值。 
```
Copy  a(i)= b(i)
Scale a(i)= q∗b(i)
Add   a(i)= b(i) +c(i)
Triad a(i)= b(i) +q∗c(i)
```
基本原则：每个数组必须不小于最后一级Cache(LLC)大小的4倍或者100万个元素 (取两者中较大)。 

### 12.2.2 SPEC CPU 基准测试程序
SPEC 组织创建了 SPEC CPU 系列测试程序集，主要关注 CPU 的性能。
SPEC CPU 测试中，测试系统的处理器和编译器都会影响最终的测试性能，而磁盘、网络等 IO 和图形子系统对于 SPEC CPU 的影响比较小。 
SPEC CPU 基准测试程序特别适用于桌面系统和单 CPU 服务器系统的 CPU 性能测试。

为了便于比较，SPEC CPU 被测计算机的执行时间标准化，即
SPECratio=被测计算机的执行时间/参考计算机的执行时间
SPECratio值越大，表示性能越好。综合测试结果是取所有程序 SPECratio 的几何平均值。
为了测试多核系统的吞吐能力，SPEC  CPU 还可以测试多个 CPU 核同时执行多份程序拷贝时的性能，并且把 CPU 的时间转换为 SPECrate 分数。

EEMBC：嵌入式系统基准测试集
覆盖汽车电子、工业、通用应用、消费类和数字图像处理、网络应用、办公自动化、通讯和数字信号处理，也可用于通用CPU的硅前性能验证。

### 12.2.3 并行系统基准测试程序
多核、多处理器等并行系统，和单线程系统不同的是其存在并行性瓶颈。
1. 多个线程之间共享资源的竞争
2. 算法中数据相互依赖

并行基准测试程序用于测试和评价并行系统的性能
1. SPLASH-2：测并行加速比
2. PARSEC：测并行加速比
3. NPB：测并行加速比
4. LINPACK：测并行浮点峰值

### 12.2.4 其他常见的基准测试程序集
见ppt（P44）

## 12.3 性能分析方法
### 12.3.1 概述
##### 性能分析和评估的分类
1. 性能建模
	1. 基于分析和统计的建模：概率模型、队列模型、马尔可夫模型、Petri网模型
	2. 基于模拟的建模
2. 性能测量

##### 性能建模和性能测量技术特性
1. 性能模型和测量结果要比较精确，因为这些性能结果会直接影响到设计的权衡和选择。
2. 性能模型的速度要比较快，否则设计空间的探索范围会变得很有限。
3. 性能模型和测量工具的开销不能太大。
4. 性能模型上所执行的测试程序应该是目标代码，不需要应用程序的源代码，否则就不能对一些商业的应用程序进行性能评价。
5. 性能模型要能捕获用户态和内核态的行为特性，能测量机器中所有的活动部分。
6. 性能模型和测量工具需要能很好地利用多处理器系统资源。
7. 性能模型和测量工具应该是非侵入式的，因为侵入式的方法会在测量过程中改变系统的行为和大幅度地降低系统的性能。
8. 性能模型和测量工具应该很容易修改和扩展，能对新的设计进行建模和测量。
这些需求通常是相互冲突的，难以同时到达，只能进行取舍。

### 12.3.2 模拟建模的方法和模拟器
模拟建模：使用软件的方式来模拟计算机系统硬件在体系结构层面的功能和性能特性。 

##### 模拟器特点
**模拟器需求**
模拟器需要有运行速度快、模拟精度高、配置修改灵活等特点，但这些需求相互矛盾，很难兼得。

**模拟器贯穿系统设计的整个流程**
初期：模拟器用来对各种设计方案进行粗粒度模拟，通过比较模拟结果来选择最优设计方案。
中期：模拟器用来对各种微结构设计进行评估，对一些微结构参数的选择进行折中。
后期：模拟器需要和目标系统进行性能验证，保证性能模型和实际机器的吻合。 
系统完成之后：模拟器可以用来产生踪迹信息, 对系统进行瓶颈分析和性能优化。 

**模拟器优缺点**
优点：灵活和开销小，通常用高级语言编写。
缺点：需要大量的时间或大量的计算资源来精准地建模一个相对较大和复杂的系统。

模拟器使用 C、 C++和 Python 等高级语言开发，利用这些串行结构化语言的函数或者类来模拟计算机系统部件的功能和行为。 
模拟器最直接的方法就是将目标机器的二进制代码中的每一条指令都转换为同样语义的宿主机器的指令，在宿主机器上执行。 
通过将目标机器的每一个寄存器和标识位对应一个变量，目标机器的所有逻辑操作都可以被间接地翻译为变量的运算和各种各样的简单或者复杂的算法操作，这样目标机器上程序的所有操作都可以在宿主机器上以软件模拟的形式复现出来。  

在进行微结构级的详细模拟时，模拟器需要在时钟周期级别上记录每条动态指令的运行结果、每一级流水线触发器的状态、内部各种队列的状态以及体系结构寄存器的状态、内存和 Cache 的行为、分支预测器的状态等，其数据量巨大，从而导致详细模拟运行的速度缓慢。

通常，模拟器比真实硬件的速度慢几个数量级，模拟的结果也会受到人为因素的干扰，因为模拟器会带来一些非真实的假设。相对于模拟器而言，基于实际机器或者原型系统的性能测量方法会更为精准一些。

##### 模拟加速技术
为了在模拟速度和精度之间进行较好的折中，多种模拟加速技术被开发出来。

**采样模拟技术**
采样模拟技术截取程序的一小部分进行模拟，并将其作为整个程序模拟结果的一个近似，如果采样程序能代表整个程序，则能获得较高的精度。 
通常采样方法有随机采样、 SMARTS 和 SimPoint。
1. SMARTS：对整个程序进行周期采样。
2. SimPoint：首先找到程序执行的相位 (这里的相位表示程序在执行过程中重复出现的行为)，然后对能够代表每个相位的部分进行采样和模拟仿真，这种采样方法大大减少了模拟时间。 

**统计模拟技术**
统计模拟技术和采样模拟技术一样，着眼于缩小需要模拟的指令数。 
该技术使用统计方法对工作负载进行分析，并利用这些统计信息 (包括指令类型分布、指令组合、指令间相关信息、分支预测率和 Cache 命中率等) 综合生成合成的程序踪迹。
这种合成的程序踪迹实际上是对工作负载的抽象，能够在一定程度上反映工作负载的行为，可以比详细模拟器大幅度降低模拟时间。
该方法在模拟速度和精度上有很大的优势，相对详细的模拟器，这种技术开发时间短，但是模拟的详细程度或覆盖度比详细的模拟及采样模拟技术差。

**时序优先技术**
性能模拟器需要模拟时序信息，如果将功能和时序模拟结合在一起，则模拟器实现过于复杂，调试维护难度大。
将功能模拟和时序模拟分开，时序模拟主要提高模拟器精度，功能模拟主要是保证模拟的正确性。

##### 模拟器精度和校验
模拟器的精度：该模拟器的模拟结果与真实机器接近的程度
1. 对于已有系统，模拟器的精度可以通过和实际系统运行结果对比，
2. 对于正在实现的系统，模拟器的精度可以通过和RTL代码模拟结果对比。

模拟器的精度受两方面影响
1. 模拟器的模型是否与真实设计相匹配
2. 模型的输入数据是否真实
模拟器的精度是一个持续改进的过程。可结合真实结果对模拟器的参数进行校验。

对未来的系统，模拟器可以用来进行设计方案的前期比较。
一个模拟器的绝对误差是无法避免的，但模拟结果和真实系统的偏差是稳定的，同一个模拟器对不同系统模拟结果的**相对值**可以相对反映这些目标系统性能的差异。

### 12.3.3 性能测量的方法


## 12.4 性能测试和分析实例
### 12.4.1 SPEC CPU 基准测试程序的分值对比
### 12.4.2 微结构相关统计数据
### 12.4.3 基础性能参数