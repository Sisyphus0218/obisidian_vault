#计算机体系结构-指令系统结构
## 2.1 指令系统简介
软件以指令形式运行在 CPU 硬件上。
指令系统介于软件和硬件之间，是软硬件交互的界面。
软硬件本身的更新迭代速度很快，而指令系统则可以保持较长时间的稳定。 
有了稳定不变的指令系统界面，软件与硬件得到有效的隔离，并行发展。
![[Pasted image 20221128145904.png]]

## 2.2 指令系统设计原则
指令系统的设计应遵循如下基本原则：
1. 兼容性：最好能在较长时间内保持指令系统不变并保持向前兼容。
2. 通用性：为了适应各种应用需求，如网络应用、科学计算、视频解码、商业应用等，通用CPU指令系统的功能必须完备。指令系统的设计还应满足操作系统管理的需求并方便编译器和程序员的使用。
3. 高效性：指令系统要便于CPU硬件的设计和优化。对同一指令系统，不同的微结构实现可以得到不同的性能，既可以使用先进、复杂的技术得到较高的性能，也可以用成熟、简单的技术得到一般的性能。
4. 安全性：指令系统的设计应当为各种安全性提供支持，如提供保护模式等。

影响指令系统的因素：
工艺技术、计算机体系结构、操作系统、编译技术、应用程序。

## 2.3 指令系统发展历程
### 2.3.1 指令内容的演变
##### 指令系统分类
1. 复杂指令系统 (Complex Instruction Set Computer，简称 CISC)，指令长度可变。
2. 精简指令系统 (Reduced Instruction Set Computer，简称 RISC)，指令长度比较固定。
3. 超长指令字 (Very Long Instruction Word，简称 VLIW) 指令集，本质上来讲是多条同时执行的指令的组合，其“同时执行”的特征由编译器指定，无须硬件进行判断。

##### CISC
早期的 CPU 都采用 CISC 结构，早期处理器设备昂贵且处理速度慢，设计者不得不加入越来越多的复杂指令来提高执行效率，部分复杂指令甚至可与高级语言中的操作直接对应。这种设计简化了软件和编译器的设计，但也显著提高了硬件的复杂性。

当硬件复杂性逐渐提高时，CISC 结构出现了一系列问题。 
1. 大量复杂指令在实际中很少用到，典型程序所使用的 80% 的指令只占指令集总指令数的 20%，消耗大量精力的复杂设计只有很少的回报。 
2. 复杂的微代码翻译也会增加流水线设计难度，并降低频繁使用的简单指令的执行效率。

##### RISC
针对 CISC 结构的缺点，RISC 遵循简化的核心思路。
1. 简化了指令功能，单个指令执行周期短。
2. 简化了指令编码，使得译码简单。
3. 简化了访存类型，访存只能通过 load / store 指令实现。 
RISC 指令的设计精髓：简化指令间的关系，有利于实现高效的流水线、多发射等技术，从而提高主频和效率。

RISC 指令系统的最本质特征：通过 load / store 结构简化了指令间关系
1. 所有运算指令都是对寄存器运算。
2. 所有访存都通过专用的访存指令 (load / store) 进行。

好处：
1. CPU 通过寄存器号的比较就能判断**运算指令间**以及**运算指令和访存指令间**有没有数据相关性；
2. 较复杂的**访存指令相关判断** (需要对访存的物理地址进行比较) 则只在执行 load / store 指令的访存部件上进行。
简化了**指令间相关性判断的复杂度**，有利于 CPU 采用指令流水线、多发射、乱序执行等提高性能。
因此，RISC 不仅是一种指令系统类型，同时也是一种提高 CPU 性能的技术。

##### VLIW
VLIW 结构的最初思想：最大限度利用指令级并行 (Instruction Level Parallelism，简称 ILP)，VLIW 的一个超长指令字由多个互相不存在相关性 (控制相关、 数据相关等) 的指令组成，可并行进行处理。 VLIW 可简化硬件实现，但增加了编译器的设计难度。

##### 比较
![[Pasted image 20221205164204.png]]
图 2.2 直观地给出了 RISC、 CISC、 VLIW 三种结构的指令编码。 
MIPS：三种类型的指令内部位域分配不同，但总长度均为 32 位。
X86：不同指令的长度都可能不同。
IA-64：则将三条 41 位定长指令合并为一条 128 位的 “束”。

### 2.3.2 存储管理的演变
##### 存储管理的演变经历
**连续实地址**
各程序所需的内存空间必须连续存放并保证不与其他程序产生冲突。 
这种方式不但会带来大量的内存碎片，而且难以管理多个程序的空间分配。

**段式存储管理**
将内存分为多个段和节，地址组织为相对于段地址的偏移。主要应用于早期处理器。

**页式虚拟存储管理**
将各进程的虚拟内存空间划分成若干长度相同的页，将虚拟地址和物理地址的对应关系组织为页表，并通过硬件来实现快速的地址转换。 
现代通用处理器的存储管理单元都基于页式虚拟管理，并通过 TLB 进行地址转换加速。
页式虚拟存储可使各进程运行在各自独立的虚拟地址空间中，并提供内存映射、公平的物理内存分配和共享虚拟内存等功能，是计算机系统发展过程中具有里程碑意义的一项技术。

##### 基本方法
**段式存储管理**
虚拟地址=段号+段内偏移
地址转换：
1. 根据段号检索段表，得到对应段的起始物理地址 (由段长度和基址可得)；
2. 加上段内偏移，得到最终的物理地址。 
注意：段表中存有每个段的长度，若段内偏移>段长度，将被视为不合法地址。 
段式存储中每段可配置不同的起始地址，但段内地址仍需要连续。当程序段占用空间较大时，仍然存在内存碎片等问题。
![[Pasted image 20221205164815.png]]

**页式存储管理**
虚拟地址=虚拟页号+页内偏移两部分
地址转换：
1. 根据虚拟页号检索页表, 得到对应的物理页号；
2. 与页内偏移组合得到最终的物理地址（不是加法，而是直接连在一起即可）。
![[Pasted image 20221205164821.png]]

**段页式存储管理**
虚拟地址=段号+虚拟页号+页内偏移
地址转换：
1. 根据段号查询段表得到对应段的页表起始地址；
2. 根据虚拟页号查询页表得到物理页号；
3. 与页内偏移组合得到最终的物理地址。 
注：段页式同样需要检查段地址的合法性。
![[Pasted image 20221205164828.png]]

### 2.3.3 运行级别的演变
处理器中有各种级别的资源，比如通用寄存器、控制寄存器等。为了对软件所能访问的资源加以限制, 计算机引入了运行级别的概念。
运行级别经历了无管理、 增加保护模式、 增加调试模式、 增加虚拟化支持等阶段。

##### 无管理
早期的处理器和当今的嵌入式单片机中不包含运行级别控制，所有程序都可控制所有资源。无管理的方式在安全方面毫无保障，软件必须小心设计, 确保不会相互干扰。这通常只在规模有限、 封闭可控的系统如微控制器 (Micro Control Unit，简称 MCU) 中使用。

##### 保护模式
现代操作系统 (如 Linux) 包含保护模式，将程序分为两个权限等级：用户态和核心态。
核心态：具有最高权限，可以执行所有指令、访问任意空间。 
用户态：程序只能访问受限的内存空间，不允许访问外围设备。 
用户态程序需要使用外围设备时，通过系统调用提出申请，由操作系统在核心态下完成访问。 

保护模式需要硬件支持。
1. X86 指令系统中定义了 Ring0~Ring3 四个权限等级。
2. MIPS 指令系统中定义了 user、 supervisor 和 kernel 三个权限等级。 
3. LoongArch 指令系统中定义了 PLV0~PLV3 四个权限等级，由当前模式信息控制状态寄存器 (CSR.CRMD) 的 PLV 域的值确定。 
在 LoongArch 处理器上运行的 Linux 操作系统，其核心态程序运行在 PLV0级，用户态程序通常运行在 PLV3 级。

##### 调试模式
为了方便软硬件调试，许多指令系统中还定义了调试模式和相应的调试接口。
在调试模式下，处理器所执行的程序将获得最高的权限等级，不过此时处理器所执行的指令是从外部调试接口中获得的，并且利用专用的控制状态寄存器使得被调试程序的上下文可以无缝切换。

##### 虚拟化支持
虚拟机中要支持不同的运行级别，硬件辅助虚拟化成为虚拟化发展的必然趋势。许多指令系统在硬件虚拟化支持中引入了新的运行级别，用于运行虚拟机操作系统的核心态和用户态程序。

##### 例 LoongArch 指令系统
运行级别主要包括
1. 调试模式 (Debug Mode) 。
2. 主机模式 (Host Mode)，包含 Host-PLV0~Host-PLV3。
3. 客户机模式 (Guest Mode)，包含 Guest-PLV0~Guest-PLV3。
所有运行级别互相独立，即处理器在某一时刻只能存在于某一种运行级别中。 
处理器上电复位后处于 Host-PLV0 级, 随后根据需要在不同运行级别之间转换。

不同运行级别可访问并控制的处理器资源不同。
1. 调试模式下具有最高的优先级，可以访问并控制处理器中所有的资源；
2. Host-PLV0 模式下可以访问并控制处理器中除了用于调试功能外的所有其他资源；
3. Guest-PLV0 模式下只能访问部分处理器资源，如客户机控制状态寄存器； 
4. Host-PLV1/2/3 和 Guest-PLV1/2/3 则只能访问更少的处理器资源。
![[Pasted image 20221205171331.png]]

## 2.4 指令系统组成
### 2.4.1 地址空间
##### 地址空间类型
处理器可访问的地址空间包括寄存器空间和系统内存空间。 
寄存器空间：通过编码于指令中的寄存器号寻址。
系统内存空间：通过访存指令中的访存地址寻址。

**寄存器空间**
通用寄存器：处理器中最常用的存储单元，一个处理器周期可以同时读取多条指令需要的多个寄存器值。针对浮点运算, 通常还定义了浮点通用寄存器。
专用寄存器：仅用于某些专用指令或专用功能。 
控制寄存器：控制指令执行的环境，比如是核心态还是用户态。 

**系统内存空间**
广义的系统内存空间包括 IO 空间和内存空间，不同指令集对系统内存空间的定义各不相同。
1. 独立的 IO 空间和内存空间：X86 指令集包含独立的 IO 空间和内存空间，对这两部分空间的访问需要使用不同的指令。内存空间使用一般的访存指令，IO 空间使用专门的 in/out 指令。 
2. 不区分 IO 空间和内存空间：MIPS、ARM、LoongArch 等 RISC 指令集则通常不区分 IO 空间和内存空间，把它们都映射到同一个系统内存空间进行访问，使用相同的 load/store 指令。 
	注：处理器对 IO 空间的访问不能经过 Cache，因此在使用相同的 load/store 指令既访问 IO 空间又访问内存空间时，需要定义 load/store 指令访问地址的存储访问类型。

##### 存储访问类型
存储访问类型通常根据访存地址范围来确定。 
1. 页式地址映射方式：同一页内的地址定义为相同的存储访问类型，通常作为该页的一个属性信息记录在页表项中。
2. 段式地址映射方式：同一段内的地址定义为相同的存储访问类型。

##### 指令使用数据的方式
根据指令使用数据的方式，指令系统可分为堆栈型、 累加器型和寄存器型。 
1. 堆栈型：又称零地址指令。操作数都在栈顶，在运算指令中不需要指定操作数，默认对栈顶数据进行运算并将结果压回栈顶。
2. 累加器型：称单地址指令。包含一个隐含操作数——累加器，另一个操作数在指令中指定，结果写回累加器中。
3. 寄存器型
	1. 寄存器-存储器型：每个操作数都由指令显式指定，操作数为寄存器和内存单元。
	2. 寄存器-寄存器型：又称 load-store 型。每个操作数也由指令显式指定，除了访存指令外的其他指令的操作数都只能是寄存器。所有访存都必须显式通过 load 和 store 指令来完成。

四种类型的指令系统中执行 C=A+B 的指令序列如下。
其中 A、B、C 为不同的内存地址，R1、R2 等为通用寄存器。
![[Pasted image 20221205173251.png]]

早期的计算机经常使用堆栈型和累加器型指令系统，主要目的是降低硬件实现的复杂度。
除了 X86 还保留堆栈型和累加器型外，当今的指令系统主要是寄存器-寄存器型。
使用寄存器的优势：
1. 寄存器的访问速度快，便于编译器的调度优化，
2. 可以充分利用局部性原理，大量的操作可以在寄存器中完成；
3. 寄存器之间的相关性容易判断，容易实现流水线、多发射和乱序执行等方法。

### 2.4.2 操作数
##### 数据类型
计算机中常见的数据类型包括整数、实数、字符，数据长度包括 1 字节、2 字节、4 字节和 8 字节。 X86 指令集中还包括专门的十进制类型 BCD。 
C 语言整数类型与不同指令集中定义的名称和数据长度 (以字节为单位) 的关系如下。
![[Pasted image 20221205195423.png]]

实数类型在计算机中表示为浮点类型
1. 单精度浮点数，长度为 4 字节
2. 双精度浮点数，长度为 8 字节。

在指令中表达数据类型有两种方法
1. 由指令操作码来区分不同类型，例如加法指令包括定点加法指令、单精度浮点加法指令、双精度浮点加法指令。 
2. 将不同类型的标记附在数据上，例如加法使用统一的操作码，用专门的标记来标明加法操作的数据类型。

##### 访存地址
**地址对齐**
在执行访存指令时，必须考虑的问题：访存地址是否对齐和指令系统是否支持不对齐访问。 

对齐访问：对该数据的访问起始地址是其数据长度的整数倍。
eg. 访问一个 4 字节数，其访存地址的低两位都应为 0。 

对齐访问的硬件实现较为简单，若支持不对齐访问，硬件需要完成数据的拆分和拼合。 
但若只支持对齐访问，又会使指令系统丧失一些灵活性，
eg. 串操作经常需要进行不对齐访问，只支持对齐访问会让串操作的软件实现变得较为复杂。

CISC 指令集通常支持不对齐访问。
RISC 类指令集在早期发展过程中为了简化硬件设计只支持对齐访问，不对齐的地址访问将产生异常。 近些年来伴随着工艺和设计水平的提升,越来越多的 RISC 类指令也开始支持不对齐访问以减轻软件优化的负担。

**尾端 (Endian) 问题**
不同的机器可能使用大尾端或小尾端，这带来了严重的数据兼容性问题。 
大尾端：最高有效字节的地址较小。
小尾端：最低有效字节的地址较小。 

##### 寻址方式
寻址方式指如何在指令中表示要访问的内存地址。 
计算机中常用的寻址方式如下。 
其中 mem 表示存储器， regs 表示寄存器，mem\[regs\[Rn\]\] 表示由寄存器 Rn 的值作为存储器地址所访问的存储器值。
![[Pasted image 20221205201235.png]]

寻址方式很多，但常用的寻址方式并不多。
偏移量寻址、立即数寻址和寄存器间接寻址是最常用的寻址方式，而寄存器间接寻址相当于偏移量为 0 的偏移量寻址。 因此，一个指令系统至少应支持寄存器寻址、 立即数寻址和偏移量寻址。 

### 2.4.3 指令操作和编码
##### 指令分类
1. 运算指令，包括加减乘除、移位、逻辑运算等；
2. 访存指令，负责对存储器的读写；
3. 转移指令，用于控制程序的流向；
4. 特殊指令，用于操作系统的特定用途。

##### 转移指令
在四类指令中，转移指令的行为较为特殊。
转移指令包括：条件转移、无条件转移、过程调用和过程返回等类型。 
**转移条件和转移目标地址**是转移指令的两个要素，两者的组合构成了不同的转移指令：
1. 条件转移要判断条件再决定是否转移；无条件转移无须判断条件。
3. 相对转移是程序计数器 (PC) 加上偏移量作为转移目标地址；绝对转移直接给出转移目标地址。
4. 直接转移的转移目标地址可直接由指令得到；间接转移的转移目标地址需由寄存器的内容得到。 
程序中的 switch 语句、函数指针、虚函数调用和过程返回都属于间接转移。 由于取指译码时不知道目标地址，因此硬件结构设计时处理间接跳转较麻烦。

**转移指令特点**
1. 条件转移在转移指令中最常用；
2. 条件转移通常只在转移指令附近进行跳转，偏移量一般不超过 16 位；
3. 转移条件判定比较简单，通常只是两个数的比较。 

**条件转移指令的条件判断方式**
1. 专用标志位方式：通过比较指令或其他运算指令将条件判断结果写入专用标志寄存器中，条件转移指令仅根据专用标志寄存器中的判断结果决定是否跳转。 
2. 直接比较寄存器方式：条件转移指令直接对来自寄存器的数值进行比较，并根据比较结果决定是否进行跳转。 

##### 指令编码
指令编码：操作数和操作码在整个指令码中的摆放方式。 
LoongArch 指令集的编码格式如图
![[Pasted image 20221205202149.png]]

如图，32 位的指令编码被划分为若干个区域，按照划分方式的不同共包含 9 种典型的编码格式：
1. 3 种不含立即数的格式 2R、3R、4R 
2. 6 种包含立即数的格式 2RI8、2RI12、2RI14、2RI16、1RI21 和 I26 

opcode 域：存放指令的操作码。
rd、rj、rk 和 ra 域：存放寄存器号。通常 rd 为目的操作数寄存器，rj、rk、ra 为源操作数寄存器。
Ixx 域：存放立即数。 

## 2.5 RISC 指令集比较
MIPS、PA-RISC、PowerPC、SPARCv9 和 LoongArch

### 2.5.1 指令格式比较
1. 寄存器类指令：操作码都由操作码 (OP) 和辅助操作码 (OPX) 组成，操作数都包括两个源操作数 (RS) 和一个目标操作数 (RD)；
2. 立即数类指令：都由操作码、源操作数、目标操作数和立即数 (Const) 组成，立即数的位数各有不同；
3. 跳转类指令：大同小异，PA- RISC 与其他四种差别较大。 
五种 RISC 指令集的指令编码的主要组成元素基本相同，只是在具体摆放位置上存在差别。

### 2.5.2 寻址方式比较
MIPS、SPARC 和 LoongArch 只支持四种常用的寻址方式。
PowerPC 和 PA-RISC 支持的寻址方式较多。

### 2.5.3 公共指令功能
RISC 指令集都有一些公共指令，如 load-store、算术运算、逻辑运算和控制流指令。 
不同指令集在比较和转移指令上区别较大。

1. load- store指令：load 内存->通用寄存器，store 通用寄存器->内存。 
2. ALU 指令：寄存器型的，包括加、减、乘、除、与、或、异或、移位和比较等。
3. 控制流指令：绝对转移指令和相对转移指令。
	1. 绝对转移的目标地址由寄存器或指令中的立即数给出。 
	2. 相对转移的目标地址是当前的 PC 值加上指令中的偏移量立即数。
4. 在条件转移指令：转移条件的确定有两种方式，判断条件码和比较寄存器的值。

转移延迟槽 (Delay Slot) 指令：条件转移指令的后一条指令。
1. 在早期的静态流水线中，条件转移指令在译码时，后一条指令即进入取指流水级。为避免流水线效率的浪费，有些指令集规定转移延迟槽指令无论是否跳转都要执行。MIPS、 SPARC 和 PA-RISC 都实现了延迟槽, 但对延迟槽指令是否一定执行有不同的规定。
2. 对于当今常用的动态流水线和多发射技术而言，延迟槽技术则没有使用的必要，反而成为指令流水线实现时需要特殊考虑的负担。Alpha、PowerPC 和 LoongArch 均没有采用转移延迟槽技术。

### 2.5.4 不同指令系统的特色
##### MIPS 部分指令特色
**不对齐访存指令 LWL / LWR**
LWL 指令读取访存地址所在的字并将访存地址到该字中最低位的字节拼接到目标寄存器的高位。
LWR 指令读取访存地址所在的字并将访存地址到该字中最高位的字节拼接到目标寄存器的低位。
上述字最低位和最高位字节会根据系统采用的尾端而变化，不同尾端下 LWL 和 LWR 的作用相反。 
eg. 加载地址 1 至 4 的内容到 R1 寄存器，不同尾端的指令和效果如图 2.9 所示。
![[Pasted image 20221205204136.png]]

##### SPARC 部分指令特色
**寄存器窗口**
在 SPARC 指令系统中，一组寄存器可用于构成窗口。
好处：函数调用时可不用保存现场，只需切换寄存器组。

##### PA-RISC 部分指令特色
**Nullification 指令**
除了条件转移指令，其他指令也可以根据执行结果确定下一条指令是否执行。 
eg. ADDBF (add and branch if false) 指令在完成加法后，检查加法结果是否满足条件，如果不满足就进行转移。 一些简单的条件判断可以用 Nullification 指令实现。

##### PowerPC 部分指令特色
在 RISC 结构中，PowerPC 的**寻址方式、指令格式和转移指令都是最多的**，甚至支持十进制运算，因此又被称为“RISC 中的 CISC”。  
实现同样的循环程序，PowerPC 只需要 6 条指令，Alpha 则需要 10 条指令。
原因：PowerPC 的**指令功能较强**。 
eg. 
1. LFU (load with update) 和 STFU (store with update) 除了访存外还能自动修改基址寄存器的值；
2. FMADD可以在一条指令中完成乘法和加法；
3. 转移指令 BC 可同时完成计数值减 1 和条件转移。

## 2.6 C 语言的机器表示
### 2.6.1 过程调用
C 语言中过程和函数的概念相同。 过程调用中，调用者和被调用者必须遵循同样的接口约定，包括寄存器使用、栈的使用和参数传递的约定等。

在LoongArch指令集中，
1. 函数调用的指令是BL，相对转移指令。该指令在跳转的同时还将其下一条指令的地址放入1号通用寄存器(记为$ra)中，作为函数返回地址。
2. 函数返回的指令是JR，间接跳转指令，该指令的操作数为寄存器，因此LoongArch汇编中最常见的函数返回指令是jr $ra。

除了调用和返回的指令外，函数调用和执行过程中还需要执行一系列操作：
• 调用者(S)将参数(实参)放入寄存器或栈中；
• 使用BL指令调用被调用者(R)；
• R在栈中分配自己所需要的局部变量空间；
• 执行R过程；
• R释放局部变量空间(将栈指针还原)；
• R使用JR指令返回调用者S。

默认情况下，通用寄存器\$r4~\$r11(记为\$a0~\$a7)作为参数输入，其中\$r4和\$r5同时也作为返回值，通用寄存器\$r12~\$r20(记为\$t0~\$t8)作为子程序的暂存器无须存储和恢复。LoongArch中没有专门的栈结构和栈指针，通用寄存器\$r3(记为\$sp)通常作为栈指针寄存器，指向栈顶。

![[Pasted image 20221205210724.png]]
Eg. 
add：被调用的子程序，由于程序功能很简单，因此无须使用栈来存储任何信息，其输入参数存放在\$a0、\$a1两个寄存器中，计算的结果存放在\$a0寄存器中。

ref：add程序的调用者，通过BL指令进行调用，BL指令会修改\$ra寄存器的值，因此在ref中需要将\$ra寄存器的值保存到栈中，栈顶指针和RA值存放的位置遵循LoongArch函数调用规范。add程序的返回值放在\$a0寄存器中，这同时也是ref程序的返回值，因此无须进行更多搬运。

### 2.6.2 流程控制语句
![[Pasted image 20221205211002.png]]

##### 辅助控制语句
goto语句无条件地跳转到程序中某标号处，其作用与无条件相对跳转指令相同，在LoongArch
指令集中表示为B指令跳转到一个标号。
break、continue语句的作用与goto类似，只是跳转的标号位置不同。
return语句将过程中的变量作为返回值并直接返回，在编译器中对应于返回值写入和返回操作。

##### 选择语句（汇编见课本）
if~else实现采用了BEQZ指令。
1. 当$t0寄存器的值等于0时进行跳转，跳转到标号 .L1执行“else”分支中的操作。
2. 当$t0寄存器的值不等于0时，则顺序执行“then”分支中的操作并在完成后无条件跳转到标号 .L2处绕开“else”分支。

switch~case语句的结构更为复杂，由于可能的分支数较多，通常会被映射为跳转表的形式。如果在编译选项中加入-fno-jump-tables的选项，那么switch~case语句还可以被映射为跳转级联的形式。

在这个例子中，\$t0寄存器存放各case分支的值并依次与第一个参数a(存放在\$a0寄存器中)进行比较，根据比较的结果分别跳转到指定标号。在case分支较多时，采用跳转表实现有助于减少级联的转移指令。

##### 循环语句（汇编见课本）
循环语句均可映射为条件跳转指令，与选择语句的区别就在于跳转的目标标号在程序段已执行过的位置(backward)。