#计算机体系结构-指令系统结构
## 3.1 特权指令系统简介
##### 运行模式定义及其转换
现代计算机的操作系统都实现了保护模式，至少需要用户态和核心态两种运行模式。因此，指令系统必须有相应的运行模式以做区分。比如 X86 定义了 Ring0~Ring3 四种模式，LoongArch 定义了 PLV0~PLV3 四种模式。

1. 刚开机时，CPU 初始化为操作系统核心态对应的运行模式，执行引导程序加载操作系统。 
2. 操作系统初始化后，控制 CPU 切换到操作系统用户态对应的运行模式去执行应用程序。
3. 应用程序执行过程中，如果出现用户态对应的运行模式无法处理的事件，则 CPU 会通过异常或中断回到核心态对应的运行模式，执行操作系统提供的服务程序。 
4. 操作系统完成处理后再控制 CPU 返回用户态对应的运行模式，继续运行原来的应用程序或者调度另一个应用程序。 

运行模式的转换过程与虚拟存储和异常中断紧密相关。不少指令系统还支持虚拟机模式、 调试模式等，使计算机系统更为易用。

##### 虚拟存储管理
虚实地址的转换根据地址段属性的不同，有查表转换和直接映射两种方式。 
1. 查表转换：应用程序使用的主要方式。不同的进程有自己独立的虚地址空间。CPU 执行访存指令时，根据操作系统给出的映射表来完成虚地址空间到物理内存的转换。
2. 直接映射：与使用物理地址差别不大，主要给操作系统使用，因为在初始化之前负责虚存管理的代码本身不能运行在被管理的虚地址空间。通常用户态应用程序无法使用直接映射方式。

##### 异常与中断处理
异常与中断是一种打断正常的软件执行流，切换到专门的处理函数的机制。它在各种运行模式的转换中起到关键的纽带作用。 
比如用户态代码执行过程中，当出现
1. 对特权空间的访问；
2. 访问了虚实地址映射表未定义的地址；
3. 需要调用操作系统服务等情况；
CPU 通过发出异常来切换到核心态，进入操作系统定义的服务函数。 
操作系统完成处理后，返回发生异常的代码并同时切换到用户态。

##### 控制状态寄存器
控制状态寄存器位于一个独立的地址空间，是支撑前面 3 种机制的具体实现，不同的指令系统差别较大。 
控制状态寄存器虽然重要，但对其操作的频率通常远远低于通用寄存器，所以指令系统中通常不会设计针对控制状态寄存器的访存和复杂运算指令。 
不过大多数指令系统至少会定义若干在控制状态寄存器和通用寄存器之间进行数据搬运的指令，从而可以将数据移动到通用寄存器中进行相关处理，或者进一步将处理结果写回控制状态寄存器中。

## 3.2 异常与中断
### 3.2.1 异常分类
从来源来看，异常可以分为以下6种。

**（1）外部事件**
来自CPU核外部的事件，来自处理器内部其他模块或者处理器外部的真实物理连线也称为中断。 中断的存在使得 CPU 能够异步地处理多个事件。在操作系统中，为了避免轮询等待浪费 CPU 时间，与 IO 相关的任务通常都会用中断方式进行处理。中断事件的发生往往是软件不可控制的，因此需要一套健全的软硬件机制来防止中断对正常执行流带来影响。

**（2）指令执行中的错误**
执行中的指令的操作码或操作数不符合要求，例如不存在的指令、除法除以 0、地址不对齐、用户态下调用核心态专有指令或非法地址空间访问等。这些错误使得当前指令无法继续执行，应当转到出错处进行处理。

**（3）数据完整性问题**
当使用 ECC 等硬件校验方式的存储器发生校验错误时，会产生异常。可纠正的错误可用于统计硬件的风险，不可纠正的错误则应视出错位置进行相应处理。

**（4）地址转换异常**
在存储管理单元需要对一个内存页进行地址转换，而硬件转换表中没有有效的转换对应项可用时，会产生地址转换异常。

**（5）系统调用和陷入**
由专有指令产生，目的是产生操作系统可识别的异常，用于在保护模式下调用核心态的相关操作。

**（6）需要软件修正的运算**
常见的是浮点指令导致的异常，某些操作和操作数的组合硬件由于实现过于复杂而不愿意处理，寻求软件的帮助。

### 3.2.2 异常处理
##### 异常处理流程
流程：异常处理准备、确定异常来源、保存执行状态、处理异常、恢复执行状态并返回等。 
主要内容：确定并处理异常，同时正确维护上下文环境。 
异常处理是一个软硬件协同的过程，通常 CPU 硬件需要维护一系列控制状态寄存器 (域) 以用于软硬件之间的交互。

**1. 异常处理准备**
当异常发生时，CPU 在转而执行异常处理前，硬件需要进行一系列准备工作。
1. 记录被异常打断的指令的地址 (记为 EPTR)。 
精确异常：发生任何异常时，被异常打断的指令之前的所有指令都执行完，而该指令之后的所有指令都像没执行一样。 
在实现精确异常的处理器中，异常处理程序可忽略因处理器流水线带来的异常发生位置问题。 
异常处理结束后将返回 EPTR 所在地址，重新执行被异常打断的指令，因此需要将 EPTR 记录下来。 
EPTR 存放的位置因不同指令集而不同。
LoongArch 存于 CSR. ERA；X86 则用栈存放 CS 和 EIP 组合。
 ^bc056c
2. 调整 CPU 的权限等级 (通常调整至最高特权等级) 并关闭中断响应。
在 LoongArch 指令系统中，当异常发生时，硬件会将 CSR.PLV 置 0 以进入最高特权等级，并将 CSR.CRMD的 IE 域置 0 以屏蔽所有中断输入。

3. 硬件保存异常发生现场的部分信息。 
在 LoongArch 指令系统中，异常发生时会将 CSR.CRMD 中的 PLV 和 IE 域的旧值分别记录到 CSR.PRMD 的 PPLV 和 PIE 域中，供后续异常返回时使用。

4. 记录异常的相关信息。 
异常处理程序利用这些信息完成或加速异常的处理。如记录异常编号以用于确定异常来源。 
在 LoongArch 指令系统中，这一信息将被记录在CSR. ESTAT 的 Ecode 和 EsubCode 域。前者存放异常的一级编号，后者存放异常的二级编号。
有些情况下还会将引发异常的指令的机器码记录在 CSR.BADI 中，或是将造成异常的访存虚地址记录在 CSR.BADV 中。

**2. 确定异常来源** 
不同类型的异常需要各自对应的异常处理。
处理器确定异常来源主要有两种方式:
1. 将不同的异常进行编号，异常处理程序据此进行区分并跳转到指定的处理入口；
2. 为不同的异常指定不同的异常处理程序入口地址，这样每个入口处的异常处理程序自然知晓待处理的异常来源。 

X86 由硬件进行异常和中断号的查询，根据编号查询预设好的中断描述符表得到不同异常处理的入口地址，并将 CS/EIP 等压栈。 
LoongArch 将不同的异常进行编号，其异常处理程序入口地址采用“入口页号与页内偏移进行按位逻辑或”的计算方式。

**3. 保存执行状态**
在操作系统进行异常处理前，软件要先保存被打断的程序状态，通常至少需要将通用寄存器和程序状态字寄存器的值保存到栈中。

**4. 处理异常** 
跳转到对应异常处理程序进行异常处理。

**5. 恢复执行状态并返回**
在异常处理返回前，软件需要先将前面第 3 个步骤中保存的执行状态从栈中恢复出来，在最后执行异常返回指令。 之所以要采用专用的异常返回指令，是因为该指令需要原子地完成恢复权限等级、恢复中断使能状态、跳转至异常返回目标等多个操作。 
在 LoongArch 中，异常返回的指令是 ERTN，X86 的 IRET指令有类似效果。 ^a99922

##### 异常嵌套
在异常处理的过程中，又有新的异常产生，这时就会出现异常嵌套的问题。 

当产生异常嵌套时，需要保存被打断的异常处理程序的状态，这会消耗一定的栈资源，因此无限的异常嵌套是无法容忍的。 
异常嵌套通常基于优先级，只有优先级更高的异常才能进行嵌套，低优先级或同优先级的异常只能等待当前异常处理完成，系统支持的优先级级数就是异常嵌套的最大层数。

在 LoongArch 指令系统中，异常嵌套时被打断的异常处理程序的状态的保存和恢复主要交由软件处理，这就需要保证异常处理程序
1. 在完成当前上下文的保存操作之前，不会产生新的异常；
2. 或者产生的新异常不会修改当前需要保存的上下文。 

这两方面要求仅通过异常处理程序开发人员的精心设计是无法完全保证的，因为总有一些异常的产生原因是事先无法预知的，如中断、 机器错、 TLB 重填等。 
为此需要设计硬件机制以保证这些情况发生时不至于产生嵌套异常，或即使产生嵌套异常也能保证软件可以获得所要保存上下文的正确内容。 
eg. 
1. 在跳转到异常入口的过程中关闭全局中断使能以禁止中断异常发生。
2. 在发生嵌套异常的时候将可能被破坏而软件又来不及保存的上下文信息由硬件暂存到指定的控制状态寄存器或内存区域。

### 3.2.3 中断
异常处理的流程是通用的，但有两类异常出现的机会比其他类型大很多。 
1. 地址转换异常：片内从虚地址到物理地址的地址转换表不包含访问地址。
2. 中断：在外部事件想要获得 CPU注意时产生。由于外部事件的不可控性，中断处理所用的时间较为关键。

##### 1. 中断传递机制
中断从系统中各个中断源传递到处理器主要有两种形式：中断线和消息中断。

**中断线**
最简便直接的方式。
1. 当系统的中断源不多时，直接连到处理器引脚即可。 
2. 若中断源较多，可使用中断控制器汇总后再与处理器引脚相连。 
由于连线会占用引脚资源，一般只在片上系统 (System On Chip，简称 SoC) 中才会给每个外设连接单独的中断线，板级的中断线一般采用共享的方式。 
eg. PCI 上有四根中断线，供所有的设备共享。中断处理程序在定位到哪根中断线发生中断后，逐个调用注册在该中断线的设备中断服务。

限制
1. 扩展性不够强，在搭建较复杂的板级系统时会引入过多的共享，降低中断处理的效率。 
2. 中断处理过程需要通过查询中断控制器以及设备上的状态寄存器来确认中断和中断原因，中间有较长的延迟，同样不利于提高效率。

**消息中断**
消息中断以数据的方式在总线上传递。发中断就是向指定的地址写一个指定的数。 
相比在总线外增加专门的中断线的“带外”(Side-Band) 传输形式，消息中断在“带内”(In-Band) 传输。 
好处：增加中断时不需要改动消息传递的数据通路，因而有较高的扩展性和灵活性，也为更高程度的优化提供了可能。比如一个设备可以申请更多的中断号，使中断处理程序无须查询设备状态，只根据中断号就能知道应当做什么处理。

##### 2. 向量化中断
LoongArch：13 个中断线各自具有独立的中断处理程序入口地址。
中断被视作一类特殊的异常进行处理。
好处：省去了中断处理程序开头处识别具体中断源的开销，可以进一步加速中断的处理。

X86：在地址空间的指定位置处存放中断向量表或中断描述符表。
中断向量表：存放中断入口地址的段地址和偏移量, 
中断描述符表：包含权限等级和描述符类别的信息。 
X86 的向量化中断机制最多可支持 256 个中断和异常。

##### 3. 中断的优先级
在支持多个中断源输入的指令系统中，需要规范在多个中断同时触发的情况下，处理器是否区别不同来源的中断的优先级。 

当采用非向量中断模式的时候，处理器通常不区别中断的优先级，此时若需要对中断进行优先级处理，可以通过软件方式予以实现，其通常的实现方案是：
1. 软件随时维护一个中断优先级 (IPL)，每个中断源都被赋予特定的优先级。
2. 正常状态下，CPU 运行在最低优先级，此时任何中断都可触发。
3. 当处于最高中断优先级时, 任何中断都被禁止。
4. 更高优先级的中断发生时, 可以抢占低优先级的中断处理过程。

当采用向量中断模式的时候，处理器通常不可避免地需要依照一套既定的优先级规则来从多个已生效的中断源中选择一个，跳转到其对应的处理程序入口处。 

##### 4. 中断使能控制位的原子修改
在中断处理程序中，经常会涉及中断使能控制位的修改，如关闭、 开启全局中断使能。 
在大多数指令系统中，这些中断使能控制位位于控制状态寄存器中，因此软件在进行中断使能控制调整时，必须关注修改的原子性问题。 

保证原子性的方法：
1. 添加专门的位原子修改指令。
2. 在程序执行时禁用中断。
3. 不允许中断处理程序修改 SR。
4. 使用通用的方法保证程序段的原子性，即将被访问的控制寄存器作为临界区来考虑。

## 3.3 存储管理
### 3.3.1 存储管理的原理
##### 存储管理概念
存储管理构建虚拟的内存地址，并通过 MMU 进行虚拟地址到物理地址的转换。 

##### 存储管理的作用和意义
1. 隐藏和保护：用户态程序只能访问受限内存区域的数据，其他区域只能由核心态程序访问。引入存储管理后，不同程序仿佛在使用独立的内存区域，互相之间不会影响。此外，分页的存储管理方法对每个页都有单独的写保护，核心态的操作系统可防止用户程序随意修改自己的代码段。
2. 为程序分配连续的内存空间：MMU 可以由分散的物理页构建连续的虚拟内存空间，以页为单元管理物理内存分配。
3. 扩展地址空间：通过 MMU 进行转换则可以访问更大的物理内存空间。
4. 节约物理内存：程序可以通过合理的映射来节约物理内存。
	1. 当操作系统中有相同程序的多个副本同时运行，可让它们使用相同的程序代码和只读数据。
	2. 在运行大型程序时，操作系统只在确实需要使用特定页时再通过存储管理的相关异常处理来分配内存，节约了物理内存，提高程序初次加载的速度。

##### 页式存储管理
操作系统将内存空间分为若干个固定大小的页，并维护虚拟页地址和物理页地址的映射关系。
虚拟内存地址可表示为虚拟页地址和页内偏移两部分，在进行地址转换时通过查表的方式将虚拟页地址替换为物理页地址就可得到对应的物理内存地址。

**TLB** 
也称页表缓存或快表，借由局部性原理，存储当前处理器中最经常访问页的页表。
TLB 中存储的内容：虚拟地址、物理地址和保护位等。

处理器用地址空间标识符 (ASID) 和虚拟页号 (VPN) 在 TLB 中进行查找匹配，
1. 若命中，读出其中的物理页号 (PPN) 和标志位 (Flag)。 
	1. 标志位：判断该访问是否合法，包括是否可读可写可执行等，若非法则发出非法访问异常。
	2. 物理页号：用于和页内偏移 (Offset) 拼接组成物理地址。 
2. 若未命中，则需要将页表内容从内存中取出并填入 TLB 中（TLB 重填）。
	1. TLB 重填可由硬件或软件进行。
	2. X86、 ARM 处理器采用硬件 TLB 重填，由硬件完成页表遍历，将所需的页表项填入 TLB中；
	3. MIPS、 LoongArch 处理器采用软件 TLB 重填，触发TLB 重填异常，由异常处理程序进行页表遍历并进行 TLB 填入。

### 3.3.2 TLB的结构和使用
##### 地址空间和地址翻译模式
LoongArch指令系统的MMU支持的模式：
1. 直接地址翻译模式：物理地址默认直接等于虚拟地址(高位不足补0、超出截断)，可以认为整个虚拟地址空间都是合法的。
2. 映射地址翻译模式：地址翻译时将优先看其能否按照直接映射模式进行地址翻译，无法进行后再通过页表映射模式进行翻译。
	1. 直接映射地址翻译模式(简称“直接映射模式”)：通过直接映射配置窗口机制完成虚实地址翻译，即将一大段连续的虚地址空间线性连续地映射至一段相同大小的物理地址空间。
	2. 页表映射地址翻译模式(简称“页表映射模式”)：通过页表映射完成虚实地址转换。

##### TLB结构
页表映射模式存储管理的核心部件是TLB。LoongArch指令系统的TLB分为两个部分，
（1）单一页大小TLB (STLB，Singular-Page-Size TLB)：所有表项的页大小相同。
（1）多重页大小TLB (MTLB，Multiple-Page-Size TLB)：不同表项的页大小可以不同。

TLB单个表项的结构
![[Pasted image 20221206204116.png]]
E：该TLB表项是否存在，E=0的项在进行TLB查找时将被视为无效项；
ASID：该TLB表项属于哪个地址空间，只有CPU中当前的ASID(由CSR.ASID的ASID域决定)与该域相同时才能命中，ASID用于区分不同进程的页表；
G：全局域，G=1时关闭ASID匹配，表示该TLB表项适用于所有的地址空间；
PS：该页表项中存放的页大小，数值是页大小的2的幂指数，有6比特宽，因此LoongArch指令系统的页大小理论上可以任意变化，处理器可以实现其中的一段范围；
VPPN：虚双页号，在LA指令系统中，TLB的每项把两个连续的虚拟页映射为两个物理页；
PPN：物理页号，该域的实际有效宽度取决于该处理器支持的物理内存空间的大小；
PLV：该页表项对应的权限等级；
RPLV：受限权限等级使能，当RPLV=0时，该页表项可以被任何权限等级不低于PLV的程序访问，否则该页表项仅可以被权限等级等于PLV的程序访问；
MAT：控制落在该页表项所在地址空间上的访存操作的存储访问类型，如是否可通过Cache缓存等；
NX：不可执行位，NX=1表示该页表项所在地址空间上不允许执行取指操作；
NR：不可读位，NR=1表示该页表项所在地址空间上不允许执行load操作；
D：“脏”(Dirty)位，D=1表示该页表项所对应的地址范围内已有脏数据；
V：有效位，D=1表明该页表项是有效且被访问过的。

##### TLB虚实地址翻译过程
1. TLB查找，将待查虚地址 vaddr 和 CSR.ASID 中 ASID 域的值 asid 一起与STLB中每一路的指定索引位置项以及 MTLB 中的所有项逐项进行比对。
	1. 如果TLB表项的E位为1，
	2. 且vaddr对应的虚双页号vppn与TLB表项的VPPN相等(该比较需要根据TLB表项对应的页大小，只比较地址中属于虚页号的部分)，
	3. 且TLB表项中的G位为1或者asid与TLB表项的ASID域的值相等
	4. 那么TLB查找命中该TLB表项。如果没有命中项，则触发TLB重填异常(TLBR)。

2. 如果查找到一个命中项，那么根据命中项的页大小和待查虚地址确定vaddr具体落在双页中的哪一页，从奇偶两个页表项取出对应页表项作为命中页表项。

3. 如果命中页表项的V等于0，说明该页表项无效，将触发页无效异常，具体将根据访问类型触发对应的load操作页无效异常(PIL)、store操作页无效异常(PIS)或取指操作页无效异常(PIF)。

4. 如果命中页表项的V值等于1，但是访问的权限等级不合规，将触发页权限等级不合规异常(PPI)。

3. 如果上述检查都合规，还要进一步根据访问类型进行检查。
	1. 如果是一个load操作，但是命中页表项中的NR值等于1，将触发页不可读异常(PNR)；
	2. 如果是一个store操作，但是命中页表项中的D值等于0，将触发页修改异常(PME)；
	3. 如果是一个取指操作，但是命中页表项中的NX值等于1，将触发页不可执行异常(PNX)。
	4. 如果找到了命中项且经检查上述异常都没有触发，那么命中项中的PPN值和MAT值将被取出，前者用于和vaddr中提取的页内偏移拼合成物理地址paddr，后者用于控制该访问操作的内存访问类型属性。

4. 当触发 TLB 重填异常时，除了更新 CSR.CRMD 外，CSR.CRMD 中 PLV、IE 域的旧值将被记录到 CSR.TLBRPRMD 的相关域中，异常返回地址也将被记录到 CSR.TLBRERA 的 PC 域中，处理器还会将引发该异常的访存虚地址填入 CSR.TLBRBAV 的 VAddr 域并从该虚地址中提取虚双页号填入 CSR.TLBREHI 的 VPPN 域。

5. 当触发非 TLB 重填异常的其他 TLB 类异常时，除了像普通异常发生时一样更新 CRMD、PRMD 和 ERA 这些控制状态寄存器的相关域外，处理器还会将引发该异常的访存虚地址填入 CSR.BADV 的 VAddr 域并从该虚地址中提取虚双页号填入 CSR.TLBEHI 的 VPPN 域。

### 3.3.3 TLB 地址翻译相关异常的处理
##### 多级页表结构
Linux 操作系统通常采用多级页表结构。对于64位的 LoongArch 处理器，如果其有效虚地址位宽为 48 位，那么当 Linux 操作系统采用 16KB 页大小时，其页表为三级结构。

33位的虚双页号 (VPPN) 分为三个部分：
（1）最高11位作为一级页表(页目录表PGD)索引，一级页表中每一项保存一个二级页表(页目录表PMD)的起始地址；
（2）中间11位作为二级页表索引，二级页表中每一项保存一个三级页表(末级页表PTE)的起始地址；
（3）最低11位作为三级页表索引。

##### 其他TLB地址翻译相关异常处理
eg.
![[Pasted image 20221206205230.png]]

``array=(int*)malloc(0x1000);``
1. 用户程序调用内存分配函数 malloc 来分配大小为 0x1000 字节的空间，假设返回一个虚地址 0x450000。
2. 操作系统在进程的 vma_struct 链表里记录地址范围 0x450000~0x451000 为已分配地址空间，并且是可读、可写的。但操作系统只是分配了一个地址范围，还没有真实分配内存的物理空间，也没有在页表里建立页表项，TLB 里更没有——如果进程没有访问，就不用真为其分配物理空间。

``for (i=0;i<1024;i++) array[i]=0;``
接下来的 for 循环对数组 array 进行赋值
1. 用户程序试图写0x450000，TLB查找失败，触发TLB重填异常。
2. TLB重填异常处理程序从相应页表位置取入页表内容填入TLB。但该页表还没初始化。
3. 异常返回到用户程序，重新开始访问。
4. TLB表项找到，但是无效，触发store操作页无效异常。
5. 处理store操作页无效异常时，操作系统需要查找vma_struct这个结构，如果判断出这个地址已经分配，处于可写状态，这时操作系统才真正分配物理页面，并分配物理页表，将物理地址填入页表，更新TLB相应的表项。
6. store操作页无效异常处理完成之后返回，store操作再次执行，成功，因为TLB里已经有了相应的表项，并且是有效、可写的。
7. 由于分配的页面恰好为4KB大小，且在同一页中，因此后续的地址访问都会在TLB中命中，不会再产生异常。除非中间发生进程切换导致其TLB项被换出。如果发生被换出的情况，再次运行时将发生TLB重填异常从页表取得有效内容，不会再触发store操作页无效异常（因此,重填异常频率>>页无效异常）。

>必考
>LoongArch：两个连续虚页是一个TLB表项，映射到两个物理页（物理页不一定连续）。
>refill：虚地址找不到物理地址
>invalid：虚地址找到物理地址了，但这一页不在内存

```
array=(int*)malloc(0x10000);
for (i=0;i<16384;i++) array[i]=0;  // 16384=16K
```

地址空间为64KB
页大小为4KB，初次执行发生了多少次异常？
发生8次TLB重填异常（TLB一项两个连续虚页）和16次store操作页无效异常

页大小为16KB，初次执行发生了多少次异常？
发生2次TLB重填异常和4次store操作页无效异常

页大小为4KB，上述程序段执行完后发生进程切换，再切换回该进程执行程序段                   
``for (i=0;i<16384;i++) array[i]=i``;
如果进程切换时TLB项全部被替换，只发生8次TLB重填异常
如果进程切换时，array被调出内存，发生8次TLB重填异常和16次store操作页无效异常，store操作页无效异常处理时把array从硬盘调到内存
