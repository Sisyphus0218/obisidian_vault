#计算机体系结构-指令系统结构
## 4.1 应用程序二进制接口
ABI 定义了应用程序二进制代码中数据结构和函数模块的格式及其访问方式，使得不同的二进制模块之间的交互成为可能。

ABI 包括但不限于如下内容：
• 处理器基础数据类型的大小、布局和对齐要求等；
• 寄存器使用约定。它约定通用寄存器的使用方法、别名等；
• 函数调用约定。它约定参数如何传递给被调用的函数、结果如何返回、函数栈帧如何组织等；
• 目标文件和可执行文件格式；
• 程序装载和动态链接相关信息；
• 系统调用和标准库接口定义；
• 开发环境和执行环境等相关约定。

同一个指令系统上可能存在多种不同的 ABI。 
导致 ABI 差异的原因：
1. 操作系统差异：UNIX 类操作系统和Windows ABI 不同。
2. 应用领域差异：嵌入式领域和通用领域的 ABI 不同。
3. 软硬件的发展需要：更多的传参寄存器有利于提升性能；指令集由 32 位到 64 位需要新的 ABI。 

下面我们以一些具体的例子来说明 ABI 中一些比较常见的内容。

### 4.1.1 寄存器约定
本节关注 MIPS 和 LoongArch 指令系统的整数寄存器约定。

MIPS 和 LoongArch 都有 32 个整数通用寄存器，除了 0 号寄存器始终为 0 外，其他 31 个寄存器物理上没有区别。但系统人为添加了一些约定，给了它们特定的名字和使用方式。

MIPS 指令系统的流行 ABI 主要有以下三种：
1) O32。来自传统的 MIPS 约定，仍广泛用于嵌入式工具链和 32 位 Linux 中。
2) N64。在 64 位处理器编程中使用的新的正式 ABI，指针和 long 型整数的宽度扩展为 64位，并改变了寄存器使用的约定和参数传递的方式。
3) N32。在 64 位处理器上执行的 32 位程序，与 N64 的区别在于指针和 long 型整数的宽度为 32 位。

![[Pasted image 20221212213608.png]]
![[Pasted image 20221212213622.png]]

### 4.1.2 函数调用约定
LoongArch 的函数调用规范如下 (略去了少量过于复杂且不常用的细节)。
##### 整型调用规范
1. 基本整型调用规范提供了 8 个参数寄存器＄a0~＄a7 用于参数传递。前两个参数寄存器＄a0 和＄a1 也用于返回值。

 2. 标量
	1. 若一个标量宽度至多 XLEN 位 (对于 LP32ABI，XLEN= 32，对于 LPX32/ LP64，XLEN=64)：
		1. 若有参数寄存器，则在单个参数寄存器中传递。
		2. 若没有可用的寄存器，则在栈上传递。 
	2. 若一个标量宽度超过 XLEN 位，不超过 2×XLEN 位：
		1. 若有足够的参数寄存器，则可以在一对参数寄存器中传递，低 XLEN 位在小编号寄存器中，高 XLEN 位在大编号寄存器中。
		2. 若没有可用的参数寄存器，则在栈上传递标量；
		3. 若只有一个寄存器可用，则低 XLEN 位在寄存器中传递，高 XLEN 位在栈上传递。 
	3. 若一个标量宽度大于 2×XLEN 位：通过引用传递，并在参数列表中用地址替换。 
	用栈传递的标量会对齐到类型对齐 (Type Alignment) 和 XLEN 中的较大者，但不会超过栈对齐要求。 
	当整型参数传入寄存器或栈时，小于 XLEN 位的整型标量根据其类型的符号扩展至 32 位，然后符号扩展为 XLEN位。 
	当浮点型参数传入寄存器或栈时，比 XLEN 位窄的浮点类型将被扩展为 XLEN 位，而高位为未定义位。

3. 聚合体
	1. 若一个聚合体 (Struct 或者 Array) 的宽度不超过 XLEN 位：
		1. 若有参数寄存器，则在寄存器中传递，并且这个聚合体在寄存器中的字段布局同它在内存中的字段布局保持一致。
		2. 若没有可用的寄存器，则在栈上传递。 
	2. 若一个聚合体的宽度超过 XLEN 位，不超过 2×XLEN 位：
		1. 若有足够的参数寄存器，则可以在一对寄存器中传递。
		2. 若只有一个寄存器可用，则聚合体的前半部分在寄存器中传递，后半部分在栈上传递; 
		3. 若没有可用的寄存器，则在栈上传递聚合体。
		4. 由于填充 (Padding) 而未使用的位，以及从聚合体的末尾至下一个对齐位置之间的位，都是未定义的。 
	3. 若一个聚合体的宽度大于 2×XLEN 位：则通过引用传递，并在参数列表中被替换为地址。 
	传递到栈上的聚合体会对齐到类型对齐和 XLEN 中的较大者，但不会超过栈对齐要求。

4. 对于空的结构体 ( Struct) 或联合体 (Union) 参数或返回值，C 编译器会认为它们是非标准扩展并忽略；C++编译器则不是这样，C++编译器要求它们必须是分配了大小的类型 (Sized Type)。

5. 位域 (Bitfield) 以小端顺序排列。跨越其整型类型的对齐边界的位域将从下一个对齐边界开始。例如：
	- struct{int x:10; int y:12;} 是一个 32 位类型，x 为 9~0 位，y 为 21~10 位，31~22 位未定义。
	- struct{short x:10; short y:12;} 是一个 32 位类型，x 为 9~0 位，y 为 27~16 位，31~28 位和 15~10 位未定义。

6. 通过引用传递的实参可以由被调用方修改。
7. 浮点实数的传递方式与相同大小的聚合体相同，浮点型复数的传递方式与包含两个浮点实数的结构体相同。(当整型调用规范与硬件浮点调用规范冲突时，以后者为准。)
8. 在基本整型调用规范中，可变参数的传递方式与命名参数相同，但有一个例外。2×XLEN 位对齐的可变参数和至多 2×XLEN 位大小的可变参数通过一对对齐的寄存器传递 (寄存器对中的第一个寄存器为偶数，如果没有可用的寄存器，则在栈上传递。当可变参数在栈上被传递后，所有之后的参数也将在栈上被传递 (此时最后一个参数寄存器可能由于对齐寄存器对的规则而未被使用)。
9. 返回值的传递方式与第一个同类型命名参数 (Named Value) 的传递方式相同。如果这样的实参是通过引用传递的，则调用者为返回值分配内存，并将其地址作为隐式的第一个参数传递。
10. 栈向下增长 (朝向更低的地址)，栈指针应该对齐到一个 16 字节的边界上作为函数入口。在栈上传递的第一个实参位于函数入口的栈指针偏移量为零的地方，后面的参数存储在更高的地址中。
11. 在标准 ABI 中，栈指针在整个函数执行过程中必须保持对齐。非标准 ABI 代码必须在调用标准 ABI 过程之前重新调整栈指针。操作系统在调用信号处理程序之前必须重新调整栈指针，因此，POSIX 信号处理程序不需要重新调整栈指针。 在服务中断的系统中使用被中断对象的栈，如果连接到任何使用非标准栈对齐规则的代码，中断服务例程必须重新调整栈指针。但如果所有代码都遵循标准 ABI，则不需要重新调整栈指针。
12. 函数所依赖的数据必须位于函数栈帧范围之内。
13. 被调用的函数应该负责保证寄存器＄s0~＄s8 的值在返回时和入口处一致。

##### 硬件浮点调用规范
1. 浮点参数寄存器共 8 个，为＄fa0~＄fa7，其中＄fa0 和＄fa1 也用于传递返回值。需要传递的值在任何可能的情况下都可以传递到浮点寄存器中，与整型参数寄存器＄a0 ~＄a7 是否已经用完无关。
2. 本节其他部分仅适用于命名参数，可变参数根据整型调用规范传递。
3. 在本节中，FLEN 指的是 ABI 中的浮点寄存器的宽度。ABI 的 FLEN 宽度不能比指令系统的标准宽。
4. 若一个浮点实数参数不超过 FLEN 位宽，并且至少有一个浮点参数寄存器可用，则这个浮点实数参数传递到浮点参数寄存器中，否则，它将根据整型调用规范传递。当一个比 FLEN 位更窄的浮点参数在浮点寄存器中传递时，它从 1 扩展到 FLEN 位。
5. 若一个结构体只包含一个浮点实数，则这个结构体的传递方式同一个独立的浮点实数参数的传递方式一致。若一个结构体只包含两个浮点实数，这两个浮点实数都不超过 FLEN 位宽并且至少有两个浮点参数寄存器可用 (寄存器不必是对齐且成对的)，则这个结构体被传递到两个浮点寄存器中，否则，它将根据整型调用规范传递。若一个结构体只包含一个浮点复数，则这个结构体的传递方式同一个只包含两个浮点实数的结构体的传递方式一致，这种传递方式同样适用于一个浮点复数参数的传递。若一个结构体只包含一个浮点实数和一个整型 (或位域), 无论次序, 则这个结构体通过一个浮点寄存器和一个整型寄存器传递的条件是, 整型不超过 XLEN 位宽且没有扩展至 XLEN 位, 浮点实数不超过 FLEN 位宽, 至少一个浮点参数寄存器和至少一个整型参数寄存器可用, 否则, 它将根据整型调用规范传递。
6. 返回值的传递方式与传递第一个同类型命名参数的方式相同。
7. 若浮点寄存器＄fs0~＄fs11 的值不超过 FLEN 位宽, 那么在函数调用返回时应该保证它们的值和入口时一致。

为了提高效率，LoongArch 的调用约定在参考MIPS 的基础上做了较多优化。
例如，它最多能同时用 8 个定点和 8 个浮点寄存器传递 16 个参数，而 MIPS 中能用定点或者浮点寄存器来传递的参数最多为 8 个。

eg. 图 4.1 的程序用 gcc -O2 fun. c -S 得到汇编文件 (见图 4.2，略有简化，下同)。
对于第 9 个浮点参数，已经没有浮点参数寄存器可用，此时根据浮点调用规范第 4 条，剩下的参数按整型调用规范传递。因此，a9、a10、a11 和 a12 分别用＄a0~＄a3 这四个定点寄存器来传递，虽然这段代码引用的 a9 和 a11 实际上是浮点数。
![[Pasted image 20221212213156.png]]

这个程序在 MIPS N64 ABI 下的参数传递方式则有所不同。按 MIPS ABI 规则，前八个参数仍然会使用浮点参数寄存器传递，但是后四个参数将通过栈上的内存空间传递，因此 a9 和 a11会从栈中获取，如图 4. 3 所示。
![[Pasted image 20221212213242.png]]

对于可变数量参数的情况，图 4. 4 给出了一个测试案例，表 4. 3 是对应的参数传递表。 
可以看到，第一个固定参数是浮点参数，用＄fa0，后续的可变参数根据浮点调用规范第 2 条全部按整型调用规范传递，因此不管是浮点还是定点参数，都使用定点寄存器。
![[Pasted image 20221212213316.png]]
![[Pasted image 20221212213335.png]]

### 4.1.3 进程虚拟地址空间
虚拟存储管理为每个进程提供了一个独立的虚拟地址空间，指令系统、操作系统、工具链和应用程序会互相配合对其进行管理。 
1. 指令系统和 OS 会决定哪些地址空间用户可以访问，哪些只能操作系统访问，哪些是连操作系统也不能访问的保留空间。 
2. 工具链和应用程序根据不同的需要将用户可访问的地址空间分成几种不同的区域来管理。 
图 4.5 展示了一个典型 C 程序运行时的用户态虚拟内存布局。

![[Pasted image 20221209170532.png]]

C 程序的典型虚拟内存布局包括如下几部分：
- 应用程序的代码、初始化数据和未初始化数据
- 堆
- 函数库的代码、 初始化数据和未初始化数据
- 栈

应用程序的代码来自应用程序的二进制文件。 
工具链在编译链接应用程序时，会将代码段地址默认设置为一个相对较低的地址 (但一般不会为 0，地址 0 在多数操作系统中都会被设为不可访问的地址，以便捕获空指针访问) 。 
运行程序时，操作系统中的装载器根据程序文件记录的内存段信息，把代码和数据装入相应的虚拟内存地址。 
有初始值的全局变量和静态变量存放在文件的数据段中。 
未初始化的变量只需要在文件中记录其大小，装载器会直接给它分配所需的内存空间，然后清零。

未初始化数据段之上是堆空间。堆用于管理程序运行过程中动态分配的内存，C 程序中用 malloc 分配的内存由堆来管理。 
接近用户最高可访问地址的一段空间被用作进程的栈。栈向下增长，用先进后出的方式分配和释放。栈用作函数的临时工作空间，存储 C 程序的局部变量、子函数参数和返回地址等函数执行完就可以抛弃的数据。
堆需要支持任意时刻分配和释放不同大小的内存块，需要比较复杂的算法支持，因此相应的分配和释放开销也比较大。 
栈的分配和释放实质上是调整通用寄存器＄sp，开销很小，但只能按先进后出的分配次序操作。 

应用程序用到的动态函数库则由动态链接程序在空闲空间中寻找合适的地址装入，通常是介于栈和堆之间。

### 4.1.4 栈帧布局
C/C++这样的高级语言通常会用栈来管理函数运行过程使用的一些信息，包括返回地址、参数和局部变量等。 

![[Pasted image 20221209180101.png]]

栈是一个大小可以动态调整的空间，在多数指令系统中是从高地址向下增长。 
栈被组织成一个个栈帧 (一段连续的内存地址空间)，每个函数都可以有一个自己的栈帧。 
调用一个子函数时栈增大，产生一个新的栈帧，函数返回时栈减小，释放掉一个栈帧。 
栈帧的分配和释放在有些 ABI 中由调用函数负责，在有些 ABI 中由被调用者负责。

以 LoongArch LP64为例。上图是最完整的情况，同时利用了＄sp和＄fp 两个寄存器来维护栈帧。 
＄sp 寄存器指向栈顶，＄fp 寄存器指向当前函数的栈帧开始处。
编译器为函数在入口处生成一个函数头 (Prologue)，在返回处生成一个函数尾 (Epilogue)，它们负责调整＄sp 和＄fp 寄存器以生成新的栈帧或者释放一个栈帧， 并生成必要的寄存器保存和恢复代码。

![[Pasted image 20221209180356.png]]
上图简单函数用 gcc -O2 -fno-omit-frame-pointer -S 来编译，会产生图 4. 9 这样的汇编代码。

前 3 条指令属于函数头。
1. 第一条指令设立了一个 16 字节的栈帧 (LP64 要求栈帧以 16 字节对齐)。
2. 第二条指令在偏移 8 的位置保存＄fp 寄存器。
3. 第三条指令则把＄fp 指向刚进入函数时的＄sp。 
第 4 条和第 7 条指令属于函数尾，分别负责恢复＄fp 和释放栈帧。 
对这么简单的情况，维护栈帧是多余的，因此如果不加-fno-omit-frame-pointer强制使用＄fp，整个函数不再产生和释放栈帧。

大部分函数可以只用＄sp 来管理栈帧。如果在编译时能够确定函数的栈帧大小，编译器可以在函数头分配所需的栈空间 (通过调整＄sp)，这样在函数栈帧里的内容都有一个编译时确定的相对于＄sp 的偏移，也就不需要帧指针＄fp 了。 

有时候可能无法在编译时确定一个函数的栈帧大小。在某些语言中, 可以在运行时动态分配栈空间，如 C 程序的 alloca 调用，这会改变＄sp 的值。这时函数头会使用＄fp 寄存器，将其设置为函数入口时的＄sp 值，函数的局部变量等栈帧上的值则用相对于＄fp 的常量偏移来表示。

## 4.2 六种常见的上下文切换场景
### 4.2.1 函数调用
函数调用是用户主动发起的指令流和上下文改变。
普通的转移指令只改变指令流不改变上下文，函数调用则通过 ABI 约定实现了一定的上下文变化。函数调用通常伴随着栈帧的变化，此外部分寄存器也会发生变化。
根据 ABI 的约定，像＄s0~＄s8 这样约定由被调用者保存(Callee Save) 的寄存器在函数调用前后保持不变，而通用暂存器、参数寄存器等则不保证维持调用前的值。

不同指令系统实现函数调用的方式有所不同。
LoongArch 采用比较典型的 RISC 做法，硬件仅仅提供一个机制 (bl 或者 jirl 指令)，用于在改变指令流的同时保存一个返回地址到通用寄存器，其余的都由软件来约定和实现。

### 4.2.2 异常和中断
开始异常和中断处理程序之前需要保存所有可能被破坏的、原上下文可见的 CPU 状态，并在处理完返回原执行流之前恢复。 需要保存的上下文包括：
1. 异常处理代码的执行可能改变的寄存器；
2. 发生异常的地址；
3. 处理器状态寄存器；
4. 中断屏蔽位等现场信息；
5. 特定异常的相关信息 (如触发存储访问异常的地址)。 
异常和中断的处理代码通常在内核态执行，如果它们触发前处理器处于用户态，硬件会自动切换到内核态。 这种情况下通常栈指针也会被重新设置为指向内核态代码所使用的栈，以便隔离不同特权等级代码的运行信息。

对于非特别高频的异常或者中断：操作系统往往会统一简化处理，直接保存所有可能被内核修改的上下文状态，然后调用相应的处理函数，最后再恢复所有状态。
对于发生频率很高的异常或者中断：希望它的处理效率尽量高，从异常和中断处理的各个环节都可以设法降低开销。例如，可以通过专用入口或者向量中断技术来降低确定异常来源和切换指令流的开销。
不同的指令系统用不同的方法来降低上下文保存恢复的开销。
例如 LoongArch 中 TLB 重填：设置专门的异常入口，利用便签寄存器来快速获得可用的通用寄存器，以及提供两个专门的指令来进一步加速从内存页表装入 TLB 表项的过程。

### 4.2.3 系统调用
系统调用的上下文切换场景和函数调用比较类似，和普通调用相比主要多了特权等级的切换。
一些系统调用 (如 gettimeofday 系统调用) 只返回一些内核知道但用户程序不知道的信息。 

系统调用要满足安全性和兼容性两方面的要求。 
1. 安全性：在面对错误甚至恶意的应用时，内核应该是健壮的，应能保证自身的安全；
2. 兼容性：操作系统内核应该能够运行已有的应用程序，这也要求系统调用应该是兼容的，轻易移除一个系统调用是无法接受的。

Linux 内核中，每个系统调用都被分配了一个整数编号，称为调用号，其定义与具体指令系统相关。因为涉及特权等级的切换，系统调用通常被当作一种用户发起的特殊异常来处理。 异常处理程序通过调用号查表找到内核中相应的实现函数，系统调用在返回时使用 ERTN 指令来同时完成跳转用户地址和返回用户态的操作。

系统调用也需要进行参数的传递。 应该尽可能使用寄存器进行传递，避免在核心态空间和用户态空间之间进行不必要的内容复制。 
在 LoongArch 指令系统中，系统调用的参数传递有以下约定:
1. 调用号存放在＄a7 寄存器中。
2. 至多 7 个参数通过＄a0~＄a6 寄存器进行传递。
3. 返回值存放在＄a0 / ＄a1 寄存器。
4. 系统调用保存＄s0~＄s8 寄存器的内容，不保证保持参数寄存器和暂存寄存器的内容。

为了保障安全性，内核必须对用户程序传入的数组索引、指针和缓冲区长度等可能带来安全风险的参数进行检查。从用户空间复制数据时，应用程序提供的指针可能是无效的，直接在内核使用可能导致内核崩溃。因此，Linux 内核使用专用函数 copy_to_user()和 copy_from_user()来完成与用户空间相关的复制操作。它们为相应的访存操作提供了专门的异常处理代码，避免内核因为用户传入的非法值而发生崩溃。

### 4.2.4 进程
进程是程序在特定数据集合上的执行实例，一般由程序、数据集合和进程控制块三部分组成。 
进程控制块记录每个进程运行过程中虚拟内存地址、打开文件、锁和信号等资源的情况。 
切换进程时需要切换进程上下文。进程上下文包括进程控制块记录的各种信息。

进程的上下文切换主要由软件来完成。发生切换的时机主要有两种：
1. 进程主动调用系统调用时因出现无法继续运行的情况 (如等待 IO 完成或者获得锁) 而触发切换。
2. 进程分配到的时间片用完了或者有更高优先级的就绪进程要抢占 CPU 导致的切换。 

切换工作的实质：实现对 CPU 硬件资源的分时复用。 
操作系统把当前进程的运行上下文信息保存到内存中，再把选中的下一个进程的上下文信息装载到 CPU 中。 特定时刻只能由一个进程使用的处理器状态信息。
如果一些不支持共享的硬件状态信息在内存里有最新备份，切换时可以采用直接丢弃的方法。 而可以共享的硬件状态信息 (如 Cache 等)，以及用内存保存的上下文信息 (如页表等)，则不需要处理。 

不同的硬件支持可能导致不同的效率。
eg. TLB 是否可以区分来自不同进程的页表项
1. 不能区分时，每次切换进程的时候必须使所有的硬件 TLB 表项无效，每次进程开始运行时都需要重新从内存获取页表项。
2. LoongArch TLB 支持用某种进程标记 (ASID) 来区分不同进程的页表项，可以避免这种开销。 

无条件保存所有寄存器的代价比较大，操作系统常常会采用某种按需保存的优化，比如不为没有用到向量的进程保存向量状态。

### 4.2.5 线程
一个进程可以包含多个线程，这些线程之间共享内存空间和打开文件等资源，但逻辑上拥有独立的寄存器状态和栈。 现代系统的线程一般支持线程私有存储区 (Thread Local Storage, 简称 TLS)。 

线程可以由操作系统内核管理，也可以由用户态的线程库管理，或者两者混合。 
线程的实现方式对切换开销有很大的影响。 
1. Linux 系统：线程库 NPTL( Native POSIX Thread Library) 采用内核和用户 1 ∶ 1 的线程模型，每个用户级线程对应一个内核线程。 除了不切换地址空间，线程的切换和进程的大部分流程一致，都需要进入和退出核心态，经历至少两次用户态和核心态上下文的切换。因此，对一些简单测试来说，Linux 中进程和线程切换的速度差异可能不太明显。 
2. Go 语言提供的 goroutines 可以被看作一种用户级实现的轻量级线程，它的切换不需要通过内核, 一些测试表明，其切换开销可比 NPTL 小一半以上。 
进程和线程切换不仅仅有执行切换代码的直接开销，还有因为 TLB、Cache 等资源竞争导致的间接开销，在数据集比较大的时候，进程和线程的实际切换代价差异也可能较大。

适当的硬件支持也有助于提升线程切换效率。 
例如，LoongArch 的 ABI 将一个通用寄存器用作专门的＄tp 寄存器，用来高效访问 TLS 空间。切换线程时只需要将＄tp 指向新线程的 TLS，访问 TLS 的变量时用＄tp 和相应的偏移就能实现访问每个线程一份的变量。

### 4.2.6 虚拟机
我们可以把一台物理计算机虚拟成多台含 CPU、内存和各种外设的虚拟计算机。 

虚拟机的运行上下文包括 CPU、内存和外设的状态。 在虚拟机内部会发生函数调用、中断和异常、线程和进程等各种内部的上下文切换，它们的处理和物理机的相应场景类似。 但在虚拟机无法独立处理的情况下会退出虚拟机运行状态，借助宿主机的虚拟化管理软件完成任务。 虚拟机和宿主机之间的切换需要保存和恢复所有可能被修改的虚拟机相关状态信息。
eg. 对于 CPU 的状态信息，之前几种场景需要保存恢复的主要是用户可访问的寄存器，而虚拟机切换时可能还需要保存各种特权态资源，包括众多控制寄存器。 
如果系统支持在一台物理计算机上虚拟化出多个虚拟机，在物理资源少于虚拟机个数的时候，只能通过保存和恢复相关资源来维持每个虚拟机都独占资源的效果。

虚拟机可以完全由软件实现。例如，QEMU 虚拟机。在宿主机指令系统和被模拟的客户机指令系统不同时，QEMU 采用二进制翻译技术把客户机应用动态翻译成等价功能的宿主机指令。不过，这种情况下 QEMU 虚拟的客户机运行速度比较低, 一般不到宿主机的 10%。

在客户机和宿主机指令系统相同时，可通过适当的硬件支持来提升虚拟化效率。

### 4.2.7 六种上下文切换场景的对比
函数调用和系统调用：用户主动发起，可以通过 ABI 约定来避免不必要的保存恢复。 
其他几种场景：通常要达到对应用程序透明的效果，切换后可能被修改的状态都应被保存和恢复。

![[Pasted image 20221209185416.png]]


## 4.3 同步机制
现代操作系统中可能同时存在多个进程，每个进程又可能包含多个同时执行的线程。 
在 Linux 操作系统中, 某个线程正在操作的数据很可能也在被另一个线程访问。并发访问的线程可能有以下来源：

1. 另一个 CPU 核上的线程。 这是真正的多处理器系统。
2. 处于中断上下文的线程。 中断处理程序打断当前线程的执行。
3. 因调度而抢占的另一线程。 中断处理后调度而来的其他内核线程。

当线程之间出现资源访问的冲突时, 需要有同步和通信的机制来保证并发数据访问的正确性。 如在 3. 2 节中所提到的中断原子性, 线程之间的共享数据访问都应该实现原子性: 要么完全完成对数据的改动, 要么什么改变都没有发生。 Linux 中包含部分原子操作, 如 atomic_inc()函数等, 这些操作在某些指令系统中可以有特定的实现方法 (如 X86 的 lock 类指令)。 同步机制通常包括基于互斥 (Mutual Exclusive) 和非阻塞 (Non-Blocking) 两类。

### 4.3.1 基于互斥的同步机制
为了使更复杂的操作具有原子性，Linux 使用了锁机制。 

对数据进行原子操作的程序段叫作临界区，在临界区前后应该包含申请锁和释放锁的过程，申请锁失败的线程被阻塞，占有锁的进程在完成临界区操作后应该及时释放锁。

LL / SC 指令 (对 32 位操作加 . W 后缀, 64 位加 . D 后缀)。 
LL 指令：设置 LL bit，并检测访问的物理地址是否被修改或可能被修改，在检测到时将 LL bit 清除。在单处理器系统中, 异常处理会破坏 LL bit。 
SC 指令：实现带条件的存储。当 LL bit 为 0 时，SC 不会完成存储操作，而是把保存值的源操作数寄存器清零以指示失败。
Linux 中的 atomic_inc()原子操作函数可以使用 LL / SC 来实现，如下所示。

```
atomic_inc:
	ll.w   $t0, $a0, 0
	addi.w $t0, $t0, 1
	sc.w   $t0, $a0, 0
	beqz   $t0, atomic_inc
	add.w  $a0, $t0, $zero
	jr     $ra
```

当 SC 失败时，程序会自旋 (循环重试) 。由于程序很短，上述程序自旋很多次的概率还是很低的。 当 LL 和 SC 之间的操作很多，LL bit 就有较大可能被破坏，单纯的LL / SC 对复杂的操作并不适合。 
操作复杂时，可以使用 LL / SC 来构造锁，利用锁来完成线程间的同步和通信需求。 
LoongArch 指令系统中的 “测试并设置” 和自旋锁指令的实现如下所示。 “测试并设置” 指令取回锁的旧值并设置新的锁值，自旋锁指令反复自旋得到锁后再进入临界区。

```
	la.local $a0, lock
test_and_set:
	ll.w     $v0, $a0, 0
	li       $t0, 0x1
	sc.w     $t0, $a0, 0
	beqz     $t0, test_and_set

	la.local $a0, lock
selfspin:
	ll.w     $t0, $a0, 0
	bnez     $t0, selfspin
	li       $t1, 0x1
	sc.w     $t1, $a0, 0
	beqz     $t1, selfspin
	<Critical section>
	st.w     $zero, lock
	...
```

### 4.3.2 非阻塞的同步机制
基于锁的资源保护和线程同步有以下缺点：
1. 若持有锁的线程死亡、阻塞或死循环，则其他等待锁的线程可能永远等待下去。
2. 即使冲突的情况非常少，锁机制也有获取锁和释放锁的代价。
3. 锁导致的错误与时机有关，难以重现。
4. 持有锁的线程因时间片中断或页错误而被取消调度时，其他线程需要等待。

一些非阻塞同步机制可以避免上述不足之处，如事务内存 (Transactional Memory)。 
事务内存：通过尝试性地执行事务代码，在程序运行过程中动态检测事务间的冲突，并根据冲突检测结果提交或取消事务。

事务内存的核心思想与 LL / SC 是一致的，LL / SC 可以被视为事务内存的一种最基础的实现，只不过 LL / SC 的局限在于其操作的数据与寄存器宽度相同，只能用于很小的事务。


