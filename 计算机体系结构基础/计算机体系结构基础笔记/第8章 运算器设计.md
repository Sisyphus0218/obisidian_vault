#计算机体系结构-微结构
## 8.1 二进制与逻辑电路
### 8.1.1 计算机中数的表示
##### 定点数
**溢出**
n 位的二进制有符号数
原码表示范围 $[-2^{n-1}+1,2^{n-1}-1]$
补码表示范围 $[-2^{n-1},2^{n-1}-1]$
溢出：当同符号数相加或异符号数相减时，结果的数值可能超过该长度编码下可表示的范围。 

eg. 
使用 4 位二进制编码计算-7+5：
-7 补码是$1001_2$，+5 补码是 $0101_2$，两者相加是 $1110_2(-2_{10})$，两异号数相加不会溢出。 
使用 4 位二进制编码计算 5+4：
+5 补码是 $0101_2$，+4 补码是 $0100_2$，两者相加是 $1001_2(-7_{10})$，溢出。

加法溢出判断方法：如果 A 和 B 的最高位一样，但是 A+B 结果的最高位与 A 和 B 的最高位不一样，表示溢出，即两个正数相加得到负数，或两个负数相加得到正数。
减法溢出判断方法： 负数减正数结果是正数，正数减负数结果是负数，表示溢出。

##### 浮点数
计算机中的浮点数包含了符号、 尾数和阶码三个域。 
符号用一位二进制码表示，0 为正，1 为负。 
计算机内部位宽有限，尾数和阶码两者间存在一个此消彼长的关系：
1. 增加尾数的位宽会提高表示的精度但是会减少表示的范围。
2. 增加阶码的位宽会扩大表示的范围但是会降低表示的精度。
IEEE 成立委员制定了浮点数标准 IEEE754。

**IEEE 754**
IEEE 754 标准中定义了两种基本的浮点数格式：32 位的单精度格式和 64 位的双精度格式。
![[Pasted image 20221208113726.png]]

32 位单精度格式：1 位符号、8 位阶码和 23 位尾数。 
64 位双精度格式：1 位符号、11 位阶码和 52 位尾数。 
两种格式下基数均隐含为 2。

尾数用原码表示，并规格化。
规格化尾数的表示统一为 1.xxxx 的形式。 
尾数规格化后第一位总为 1，因而可以在尾数中缺省这一位 1。 
隐藏该位后尾数可以多一位表示，精度提高一位。

阶码用加偏置常量的移码表示。
偏置常量并不是通常 n 位移码所用的 $2^{n-1}$，而是 $2^{n-1}-1$。
单精度和双精度浮点数的偏置常量分别为 127 和 1023。

![[Pasted image 20221208114531.png]]

IEEE 754 标准对浮点数的一些情况做了特殊的规定，主要用阶码进行区分。
1. 无穷大（阶码全1尾数全0）：+∞ 大于所有有限浮点数，-∞ 小于所有有限浮点数。
2. 非数（阶码全1尾数非0）：非数 (NaN) 表示一个没有定义的数。
3. 规格化非0数（阶码非全0非全1）：阶码 e 的值落在\[1,254\](单精度) 和 \[1,2046\] (双精度) 范围内且尾数 f 是非 0 值的浮点数。
4. 非规格化非0数（阶码全 0 尾数非 0）：特别小的非规格化数。尾数的小数点前的 1 不再添加。
5. 零（阶码全0尾数全0）：根据符号位的取值, 分为+0 和-0。

### 8.1.2 MOS 晶体管工作原理
NMOS 晶体管：在栅极上加上电就通，不加电就断。 
PMOS 晶体管：在栅极上加上电就断，不加电就通。
![[Pasted image 20221208142130.png]]

### 8.1.3 CMOS 逻辑电路
##### 非门
![[Pasted image 20221208142302.png]]

##### 与非
![[Pasted image 20221208142335.png]]

##### 或非
![[Pasted image 20221208142347.png]]

## 8.2 简单运算器设计
### 8.2.1 定点补码加法器
##### 1位全加器
S = ~A & ~B & Cin | ~A & B & ~Cin | A & ~B & ~Cin | A & B & Cin
Cout = A & B | A & Cin | B & Cin
![[Pasted image 20221208143924.png]]
输入到S，3级门延迟。
输入到Cout，2级门延迟。

##### 行波进位加法器
构建N位加法器：将N个一位全加器串联。
![[Pasted image 20221208144305.png]]
32位行波进位加法器中，
从最低位的输入A0、B0、Cin到最高位的进位输出Cout的延迟为2×32=64级门
从最低位的输入A0、B0、Cin到最高位的进位输入Cin的延迟为2×31=62级门
从最低位的输入A0、B0、Cin到最高位的加和S31的总延迟为62+3=65级门
>n位行波进位加法器，产生S的延迟为 2×(n-1)+3

##### 先行进位加法器
每一位的进位：并行地计算每一位的进位。
每一位的结果：将本地和与进位相加即可。

**并行进位逻辑**
$c_{i+1}\,=\,a_i\&b_i\,|\,a_i\&c_i\,|\,b_i\&c_i\,=\,a_i\&b_i\,|\,(a_i|b_i)\&c_i$
设 $g_i=a_i\&b_i$ ，$p_i=a_i|b_i$，
则 $c_{i+1}=g_i\,|\,p_i\&c_i$
称$g_i$为第i位的进位生成因子，$p_i$为第i位的进位传递因子。
每一位的进位输出$c_{i+1}$可由本地信号生成的g和p直接得到，不用依赖前一位的进位输入$c_i$。

eg. 4位加法器
![[Pasted image 20221208144622.png]]
![[Pasted image 20221208144628.png]]
产生c4
行波进位逻辑：8级门延迟。
先行进位逻辑：2级门延迟。
先行进位逻辑的延迟显著地优于行波进位逻辑。
但实际实现时很少采用五输入的与非门。 ^ca6e2e

**块内并行、块间串行逻辑**
理论上可以把上述并行进位方法扩展成更多位的情况，但那需要很多输入的逻辑门，在实现上是不现实的。
实现更多位的加法器时通常采用分块的进位方法，将加法器分为若干个相同位数的块，块内通过先行进位，块间行波进位。

eg. 16位加法器
![[Pasted image 20221208145821.png]]
产生c16
行波进位逻辑：32级门延迟。
块内并行、块间串行逻辑：块内并行产生进位只需要2级门延迟，故最多只需要8级门延迟。

**块内并行、块间并行逻辑**
为了进一步提升加法器的速度，可以在块间也采用先行进位的方法，即块内并行、块间并行。
对于块内进位，定义其进位生成因子为g和进位传递因子为p。
对于块间进位，定义其进位生成因子为G和进位传递因子为P。
![[Pasted image 20221213130422.png]]
G = 1：本块有进位输出生成。
P = 1：本块有进位输入时该进位可以传播至该块的进位输出。
![[Pasted image 20221213130441.png]]

eg. 16位先行进位逻辑，采用了5块4位先行进位逻辑。
![[Pasted image 20221213130317.png]]
1. 下层的4块4位先行进位逻辑：根据各块所对应的pi和gi生成各自的块间进位生成因子G和块间进位传递因子P;（2级门延迟）
2. 上层的4位先行进位逻辑：把下层的先行进位逻辑生成的P和G作为本层的pi和gi输入，生成块间的进位c4、c8和c12;（2级门延迟）
3. 下层的每块4位先行进位逻辑：分别把c0以及上层计算出的c4、c8和c12作为各自块的进位输入c0，再结合本地的pi和gi分别计算出本块内部所需要的每一位进位。（2级门延迟）
所以整体来看，从pi和gi生成进位c1~c16最长的路径也只需要6级门延迟。

故16位先行进位一共11级门延迟。
1. 生成pi和gi需2级门延迟。
2. 从pi和gi生成进位ci需6级门延迟。
3. 从ci生成si需3级门延迟。

![[Pasted image 20221213143209.png]]

补充：
<[64位先行进位加法器的原理_BakerIsMe的博客-CSDN博客_64位二进制数据的全加器](https://blog.csdn.net/weixin_43857778/article/details/84677255)>

## 8.3 定点补码乘法器
### 8.3.2 Booth 乘法器
##### Booth一位乘
![[Pasted image 20221208154521.png]]
其中y-1取值为 0。
根据乘数的最末两位确定如何将被乘数累加到结果中，再将乘数和被乘数移一位
![[Pasted image 20221208154543.png]]
![[Pasted image 20221213132720.png]]

##### Booth两位乘算法
![[Pasted image 20221208154605.png]]
根据Booth两位乘算法，需要每次扫描3位的乘数，并在每次累加完成后，将被乘数和乘数移2位。
注意被扫描的3位是当前操作阶数i加上其左右各1位。因此操作开始时，需要在乘数最右侧隐含地补一个0。
![[Pasted image 20221208154642.png]]
![[Pasted image 20221213132656.png]]

Booth乘法的核心是部分积的生成，共需要生成N/2个部分积。
每个部分积与$[X]_补$相关，总共有-X、-2X、+X、+2X和0五种可能。
其中减去$[X]_补$的操作，可以视作加上按位取反的$[X]_补$再末位加1。为了硬件实现方便，将这个末位加1的操作提取出来。
假设$[X]_补$的二进制格式写作 $x_7x_6x_5x_4x_3x_2x_1x_0$，部分积P等于 $p_7p_6p_5p_4p_3p_2p_1p_0+c$
![[Pasted image 20221208154755.png]]
可以得出每一位pi的逻辑表达式
![[Pasted image 20221208154808.png]]

### 8.3.3 华莱士树
华莱士树由全加器搭建而成。

##### 一位全加器与华莱士树
一位全加器
S = ~A & ~B & Cin | ~A & B & ~Cin | A & ~B & ~Cin | A & B & Cin
Cout = A & B | A & Cin | B & Cin

3个1bit数相加
全加器可以将 3个1位数 A、B、C 的加法转换为 2个1位数 S 和 C 的错位加法：
A + B + C = S + (C << 1)
![[Pasted image 20221208160447.png]]

3个4bit数相加
如果参与加法的数据较宽，可以通过调用多个全加器将 3 个数的加法转换为两个数的加法。
![[Pasted image 20221208160958.png]]

4个4bit数相加
使用多层全加器
第一层：计算A + B + D，变成2个数加法 $S_{tmp}+\{C_{tmp},1'b0\}$
第二层：计算$S_{tmp}+\{C_{tmp},1'b0\}+E$，得到最终$S+\{C,1'b0\}$
![[Pasted image 20221208161122.png]]

![[Pasted image 20221208161622.png]]

华莱士树：
将N个1bit数相加，转为2个1bit数相加。

##### Booth乘法与华莱士树
接下来，根据Booth乘法的需求，设计所需的华莱士树
eg. 16bit乘法，8个32bit部分积相加。需要将8个数相加转为2个数相加。
Hint：1份全加器可以将3个数相加转为2个数相加
使用多层全加器：
第一层，使用两份全加器，将8个数转为6个数。
第二层，使用两份全加器，将6个数转为4个数。
第三层，使用一份全加器，将4个数转为3个数。
第四层，使用一份全加器，将3个数转为2个数。

![[Pasted image 20221208162921.png]]

下图是两个有问题的例子
![[Pasted image 20221208163458.png]]

8.39问题：
每一级全加器生成本地和以及向高位的进位，因此在每一级华莱士树生成的结果中，凡是由全加器的进位生成的部分连接到下一级时要连接到下一级的高位。
而8.39的C0，C3都连接的是同一级，这样会造成延迟很大。
![[Pasted image 20221208163754.png]]

8.40问题：
为了构成一个 16 位定点补码乘法器，需要使用 8 个 Booth 编码器，32 个 8 个数相加的一位华莱士树和一个 32 位加法器。 
注意：除了有 8 个部分积需要相加之外，还有 8 个 “末位加 1” 的信号。 
在华莱士树中，最低位对应的华莱士树上有空闲的进位输入信号，根据图 8. 38 的结构，共有 6 个进位输入，可以接上 6 个 “末位加 1” 的信号。还剩下两个 “末位加 1” 的信号，只能去最后的加法器上想办法。
最后的加法器负责将华莱士树产生的 2N 位的 C 和 S 信号错位相加，其中 C 信号左移一位低位补 0。因此，这两个 “末位加 1” 的信号可以一个接到加法器的进位输入上，另一个接到 C 左移后的补位上。所以图 8. 38 中的华莱士树才是合适的，因为这种搭建方法才能出现 6 个进位输入。 ^069ae0

![[Pasted image 20221208164309.png]]
switch 的部分：
1. 收集 8 个 Booth 核心生成的 8 个 32 位数，进行类似矩阵转置的操作，重新组织为 32 组 8 个一位数相加的格式，输出给华莱士树；
2. 将 Booth 核心生成的 8 个 “末位加 1” 信号从 switch 部分右侧接出，提供给华莱士树最右侧的一位树及最后的加法器。 
此外，图中没有画出的是，被乘数 X 送到 8 个 Booth 编码器时需要先扩展到 32 位，并按照编码器所处的位置进行不同偏移量的左移操作。

使用华莱士树，可以优化多个数相加的逻辑，相比使用多个加法器降低了延迟。
1. 直接顺序相加：105级延迟
2. 多个加法器树状：45级延迟
3. 使用华莱士树：
	1. 华莱士树本身：4×3=12级延迟
	2. 最后的加法器：15级延迟
	3. 共27级延迟
