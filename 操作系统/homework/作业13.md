2020K8009929017 侯昱帆
（9分）

##### 13.1 
现有一个文件系统，它的文件块索引采用多级间址。该文件系统的inode，包含10个直接指针，1个一级间址指针，1个二级间址指针和1个三级间址指针。假设文件块大小为4KB，每个文件块对应的磁盘块地址为4B。
1. 请问该索引结构能够索引的最大文件是多大?
2. 请问一个 1GB 的文件需要几级间址？它总共有多少间址块？其中，各级间址块分别是多少? 如何找到第20,000块？

**解答**
1. 每个文件块可以存储 4KB/4B = 1K =1024 个块地址
	故该索引结构支持 10 + 1024 + 1024^2 + 1024^3 =  1,074,791,434 个文件块
	最大文件 1,074,791,434 × 4KB = 4,299,165,736 KB ≈ 4TB 
	
2. 1GB 文件的文件块数为 1GB/4KB=2^18=262,144
	一级间址支持 10 + 1024 = 1034 个文件块，不够。
	二级间址支持 10 + 1024 + 1024^2 = 1,049,610 个文件块，所以需要二级间址。
	采用直接索引的文件块：10 个；
	采用一级间址的文件块：1024个；则一级间址块：1个。
	采用二级间址的文件块：262144-10-1024=261,110 个；
	则二级间址块 261,110/1024=255 个，一级间址块：1个。
	总共 1+1+255=257 个间址块。
	第 20,000 块需二级间址，20,000 - 10 - 1024 = 18,966 块。
	18966=18×1024+534，所以第20,000块在第19个二级间址块中的第534项。

![[Pasted image 20221224225527.png]]
>（-0.5）：13.1(2) 一级间址和二级间址概念反了
>一级间址：指向数据块
>N级间址：指向N-1级间址
>
>三级间址：指向的块存放的都是二级指针
>二级间址：指向的块存放的都是一级指针
>文件写入数据时，使用指针的顺序为：
>直接指针>一级间址>二级间址>三级间址

##### 13.2 
某用户X刚挂载了一个文件系统（假设此时该文件系统的所有inode已被加载到内存），该文件系统使用的磁盘块大小为4KB，能用到的page cache大小最大为512MB。随后，该用户执行如下所示程序A。请分析（请写出分析过程）
1. 当程序A打开fs02.ppt文件时，文件系统需要从磁盘读取几个磁盘块？
2. 假设该文件系统采用write through的缓存策略，当程序A完成对fs02.ppt的写入操作后，文件系统写入几个磁盘块？如果该文件系统采用的是write back缓存策略，那么程序A在写完fs02.ppt还未关闭文件时，文件系统写入几个磁盘块？
3. 程序A执行完成后，用户Y再次运行该程序，当程序A打开fs02.ppt时，文件系统需要从磁盘读取几个磁盘块？ 
4. 用户Y将程序A中打开的文件修改为/home/os22/fs01.ppt，并编译执行程序A，那么当程序A打开fs01.ppt时，文件系统需要从磁盘读取几个磁盘块？

注：假设
（1）所有目录都只需1个磁盘块保存其内容；
（2）fs01.ppt和fs02.ppt两个文件已在文件系统中存在。

程序A代码如下
```
#define MAX (1024)
char buf[MAX];

int fd = open("/home/os22/fs02.ppt", O_CREAT | O_RDWR, 0666);
int n=0, i=0;

if (fd < 0 ) 
{
	perror("open");
	exit(-1);
}

for (i = 0; i < MAX; i++) 
{
	bzero(buf, sizeof(buf));
	sprintf(buf, "%3d\n", i);
	n = write(fd, buf, strlen(buf));
	printf("len=%d\n", strlen(buf));
	if (n != strlen(buf))
	{
		perror("write");
		printf("length=%d, buf=[%s]", strlen(buf), buf);
	}
}

close(fd);
```

**解答**
1. 2×4=8
2. 根据代码，每次循环向buf写入4B数据，循环1024次，总共写入了4KB数据。
	write through：需要写 1024 次磁盘
	write back：不需要写磁盘。
3. 不需要从磁盘上读取磁盘块，因为磁盘块在缓存中。
4. 根目录、home 和 os22 的 inode 及其第一块已经在缓存中，所以只需要读 fs01.ppt 的 inode 和第一块，故只需读2个块。

>（-0.5）：13.2(1)(4) inode已缓存，且打开文件时不读数据块
>注意，题目中已说文件系统的所有inode已被加载到内存，所以访问inode不用读磁盘块。
>“打开文件”时，只读inode，不读取数据块。
>/home/os22/fs02.ppt包含三级目录：root，home和os
>首次打开时，需要访问4个inode和3个目录数据块
>但是inode已经在内存，所以第一问只用读3个磁盘块
>再次访问同目录下文件时，目录数据块都已缓存，所以第三题第四题都是0个。

```
#define MAX (1024)  // 注意sprintf中格式为%3d，但是MAX为1024
                    // 取值达到1000后会超过%3d限制，所以其实最后一些字符串长度为4+1=5B
                    // 但是情况有些复杂，这里就不考虑了。。
char buf[MAX];

int fd = open("/home/os22/fs02.ppt", O_CREAT | O_RDWR, 0666);
int n=0, i=0;

if (fd < 0 ) 
{
	perror("open");
	exit(-1);
}

for (i = 0; i < MAX; i++) 
{
    // void bzero(void *s, int n), 将内存块的前n个字节清零
	bzero(buf, sizeof(buf));  
	// sprintf(char *str, const char *format, ...), 发送格式化输出到str所指向的字符串
	sprintf(buf, "%3d\n", i); 
	n = write(fd, buf, strlen(buf));  // 字符串以'\0'结尾，长度为3+1=4B
	printf("len=%d\n", strlen(buf));
	if (n != strlen(buf))
	{
		perror("write");
		printf("length=%d, buf=[%s]", strlen(buf), buf);
	}
}

close(fd);
```

>每次写入4B，共计 1024 次，所有写均在一个 4KB 块内。
>注意 write through 1024 次磁盘写，每次调用 write 写一个块，即 4KB，这里会有一个写放大。
>实际产生的 IO 是 4KB×1024=4MB