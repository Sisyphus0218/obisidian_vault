# 第4章 语法分析
## 4.1 引论
### 4.1.1 语法分析器的作用
语法分析器：从词法分析器获得一个由词法单元组成的串，并验证这个串可以由源语言的文法生成  
方法：构造出一棵语法分析树，并把它传递给编译器的其他部分进一步处理

自顶向下：从根结点向叶子结点构造语法分析树  
自底向上：从叶子结点向根结点构造语法分析树

两种分析方法中，语法分析器的输入总是按照从左向右的方式被扫描，每次扫描一个符号

### 4.1.2 代表性的文法
指明了运算符的结合性和优先级的文法  
$E\rightarrow E+T$ | $T$  
$T\rightarrow T*F$ | $F$  
$F\rightarrow(E)$ | $id$

无左递归  
$E\rightarrow TE'$  
$E'\rightarrow +TE'$ | $\epsilon$  
$T\rightarrow FT'$  
$T'\rightarrow *FT'$ | $\epsilon$  
$F\rightarrow (E)$ | $id$

二义性的文法  
$E\rightarrow E+E$ | $E*E$ | $(E)$ | $id$

### 4.1.3 语法错误的处理
1. 词法错误
2. 语法错误
3. 语义错误
4. 逻辑错误

### 4.1.4 错误恢复策略
1. 恐慌模式的恢复
2. 短语层次的恢复
3. 错误产生式
4. 全局纠正

## 4.2 上下文无关文法
### 4.2.1 上下文无关文法的正式定义
上下文无关文法（简称文法）由终结符号、非终结符号、一个开始符号和一组产生式组成

### 4.2.2 符号表示的约定
略

### 4.2.3 推导
如果 $S\stackrel{*}{\Rightarrow}\alpha$，其中 $S$ 是文法 $G$ 的开始符号，称 $\alpha$ 是 $G$ 的一个句型  
文法 $G$ 的句子是不包含非终结符的句型

最左推导：总是替换句型中最左非终结符号  
最右推导：总是替换句型中最右非终结符号

### 4.2.4 语法分析树和推导
语法分析树过滤了推导过程中对非终结符号应用产生式的顺序

语法分析树每个内部结点表示一个产生式的应用  
该内部结点的标号：此产生式头中的非终结符号 $A$  
该结点的子结点标号：从左到右组成了在推导过程中替换这个 $A$ 的产生式体

### 4.2.5 二义性
二义性：一个文法可以为某个句子生成多棵语法分析树  
二义性文法对同一个句子有多个最左推导或多个最右推导

eg. 

![assembly-4-1](assets/assembly-4-1.png)

![assembly-4-2](assets/assembly-4-2.png)

### 4.2.6 验证文法生成的语言
证明文法 $G$ 生成语言 $L$
1. 证明 $G$ 生成的每个串都在 $L$ 中
2. 证明 $L$ 中的每个串都确实能由 $G$ 生成

### 4.2.7 上下文无关文法和正则表达式
每个正则语言都是一个上下文无关语言，反之不成立

## 4.3 设计文法

### 4.3.1 词法分析和语法分析

略

### 4.3.2 消除二义性

eg. 悬空-else

![assembly-4-3](assets/assembly-4-3.png)

$if$ $E_1$ $then$ $if$ $E_2$  $then$ $S_1$ $else$ $S_2$ 有两棵语法分析树

![assembly-4-4](assets/assembly-4-4.png)

但是一般都会选择第一种语法分析树  
通用规则：每个 $else$ 和最近的尚未匹配的 $then$ 匹配

改写成无二义性  
基本思想：在一个 $then$ 和一个 $else$ 之间出现的语句必须是”已匹配的“

![assembly-4-5](assets/assembly-4-5.png)

### 4.3.3 左递归的消除

自顶向下语法分析方法不能处理左递归的文法，因此需要一个转换方法来消除左递归

立即左递归  
$A\rightarrow A \alpha$ | $\beta$  
消除左递归后  
$A\rightarrow \beta A'$  
$A'\rightarrow \alpha A'$ | $\epsilon$  

立即左递归  
$A\rightarrow A \alpha_1$ | $A \alpha_2$ | ... | $A \alpha_m$ | $\beta_1$ | $\beta_2$ | ... | $\beta_n$  
消除左递归后  
$A\rightarrow \beta_1 A'$ | $\beta_2 A'$ | ... | $\beta_n A'$  
$A'\rightarrow \alpha_1 A'$ | $\alpha_2 A'$| ... | $\alpha_m A'$ | $\epsilon$

系统地消除左递归
输入：没有环或 $\epsilon$ 产生式的文法 $G$  
输出：一个等价的无左递归文法  
方法：

![assembly-4-6](assets/assembly-4-6.png)

工作原理：

1. 通过 for 循环将所有产生式都变成 $A_k\rightarrow A_l \alpha$，$l\gt k$ 形式，即全部变成立即左递归
2. 消除立即左递归

eg. 文法  
$S\rightarrow Ab$ | $b$  
$A\rightarrow Ac$ | $Sd$ | $\epsilon$

经过 for 循环  
$S\rightarrow Ab$ | $b$  
$A\rightarrow  Ac$ | $Aad$ | $bd$ | $\epsilon$ 

消除立即左递归  
$S\rightarrow Ab$ | $b$  
$A\rightarrow bdA'$ | $A'$  
$A'\rightarrow cA'$ | $adA'$ | $\epsilon$ 

### 4.3.4 提取左公因子

提取左公因子可以产生适用于预测分析技术或自顶向下分析技术的文法  
不清楚应该在两个 A 产生式中如何选择时，可以通过改写产生式来推后这个决定，等读入了足够的输入后再做出正确选择

原产生式  
$A\rightarrow \alpha \beta_1$ | $\alpha \beta_2$  
提取左公因子  
$A\rightarrow \alpha A'$  
$A'\rightarrow \beta_1$ | $\beta_2$

原产生式  
$A\rightarrow \alpha \beta_1$ | $\alpha \beta_2$ | ... |$\alpha \beta_n$ | $\gamma$  
提取左公因子  
$A\rightarrow \alpha A'$ | $\gamma$  
$A'\rightarrow \beta_1$ | $\beta_2$ | ... | $\beta_n$ 

eg.

![assembly-4-7](assets/assembly-4-7.png)

### 4.3.5 非上下文无关语言的构造

略
