# 第5章 语法制导的翻译
## 5.1 语法制导的定义
语法制导定义 (Syntax-Directed Definition, SDD)：上下文无关文法和属性及规则的集合
属性和文法符号相关联
规则和产生式相关联

eg. 

|        产生式        |       语义规则        |
| :------------------: | :-------------------: |
| $E\rightarrow E_1+T$ | $E.val=E_1.val+T.val$ |

### 5.1.1 继承属性和综合属性
综合属性：在分析树结点N上的非终结符号A的综合属性是由N上的产生式所关联的语义规则定义的
产生式头一定是A
结点N上的综合属性只能通过N的子结点或N本身的属性定义
终结符的综合属性：词法分析器提供的词法值

eg.

|        产生式        |       语义规则        |
| :------------------: | :-------------------: |
| $E\rightarrow E_1+T$ | $E.val=E_1.val+T.val$ |

![assembly-5-1](assets/assembly-5-1.png)

继承属性：在分析树结点N上的非终结符号B的继承属性是由N的父结点上的产生式所关联的语义规则定义的
产生式体必然包含B
结点N上的继承属性只能通过N的父结点、N本身和N的兄弟结点的属性定义
终结符无继承属性

eg.

|      产生式       |    语义规则    |
| :---------------: | :------------: |
| $D\rightarrow TL$ | $L.inh=T.type$ |

![assembly-5-2](assets/assembly-5-2.png)

S属性的SDD：只包含综合属性的SDD
S属性的SDD中，每个规则都根据相应的产生式的产生式体中的属性值来计算头部非终结符号的一个属性。

eg.

![assembly-5-3](assets/assembly-5-3.png)

### 5.1.2 在语法分析树的结点上对SDD求值
注释语法分析树：带有各个属性值的语法分析树
如何构造注释语法分析树？必须求得各个结点的属性值。
如何求一个结点的属性值？必须首先求出该属性值所依赖的所有属性值。

对于综合属性的SDD，可以按照任何自底向上的顺序计算它们的值，如对语法分析树后序遍历
对于同时具有综合属性和继承属性的SDD，不能保证有一个顺序来对各结点上的属性进行求值

eg. 循环依赖

![assembly-5-4](assets/assembly-5-4.png)

![assembly-5-5](assets/assembly-5-5.png)

A.s 依赖 B.i，B.i 依赖 A.s

两个例子
eg1. 只有综合属性的SDD

![assembly-5-3](assets/assembly-5-3.png)

![assembly-5-6](assets/assembly-5-6.png)

比如 $*$ 结点的父结点
1. 计算第一个和第三个子结点上的 T.val = 3 和 F.val = 5
2. 应用相应规则，指明 T.val 就是这两个值的乘积，即 15

eg2. 具有综合属性和继承属性的SDD

![assembly-5-7](assets/assembly-5-7.png)

1. 非终结符号 T 和 F：综合属性 val
2. 终结符 digit：综合属性 lexval
3. 非终结符号 T'：继承属性 inh，综合属性 syn

![assembly-5-8](assets/assembly-5-8.png)

蓝线为继承属性，橙线为综合属性
1. 根结点左子树：
   - 最左边叶子：（综合属性）digit.lexval = 3，3由词法分析器提供
   - 叶子父结点：（综合属性）对应产生式 r4，根据 r4 关联的语义规则，F.val = digit.lexval = 3
2. 根结点右子树：
   - 根结点的第二个子结点：（继承属性）其父结点对应产生式 r1，根据 r1 关联的语义规则，T'inh = F.val = 3
   - 第二个子结点的第三个子结点：（继承属性）其父结点对应产生式 r2，根据 r2 关联的语义规则，T1'inh = T'inh × F.val = 15

这个SDD计算诸如 $3*5$ 和 $3*5*7$ 这样的项
基本思想：运算符 $*$ 的左运算分量是通过继承得到的，即产生式 $T'\rightarrow *FT_1'$ 的头 $T'$ 继承了产生式体中 $*$ 的左运算分量

eg. $x*y*z$
对应于 $*y*z$ 的子树的根结点继承了 x 的值
对应于 $*z$ 的子树的根结点继承了 $x*y$ 的值

![assembly-5-9](assets/assembly-5-9.png)


## 5.2 SDD的求值顺序
### 5.2.1 依赖图
依赖图：描述了某个语法分析树中属性实例之间的信息流
属性实例 --> 另一个属性实例：计算第二个属性实例时需要第一个属性实例的值

eg.

![assembly-5-10](assets/assembly-5-10.png)

语法分析树的边：虚线
依赖图的边：实线

### 5.2.2 属性求值的顺序
依赖图中，M --> N，先对M对应的属性求值，再对N对应的属性求值

可行求值顺序：结点顺序 $N_1, N_2, \cdots, N_k$，如果有一条从结点 $N_i$ 到 $N_j$ 的边，那么 $i\lt j$
这样的排序将一个有向图变成了一个线性排序，这个排序称为这个图的拓扑排序

如果图中存在环，则无拓扑排序，无法对 SDD 求值
如果没有环，至少存在一个拓扑排序

### 5.2.3 S属性的定义
S 属性：如果一个 SDD 的每个属性都是综合属性，它就是 S 属性的
可以按照任何自底向上的顺序计算属性值，如对语法分析树后序遍历

```c
postorder(N)
{
	for(从左边开始，对N的每个子结点 C)
		postorder(C);
	对 N 关联的各个属性求值；
}
```

### 5.2.4 L属性的定义
L属性：在一个产生式体所关联的各个属性之间，依赖图的边总是从左到右，不能从右到左

每个属性必须是
1. 综合属性
2. 继承属性，且有限制：产生式 $A\rightarrow X_1X_2\cdots Xn$，继承属性 $Xi.a$
	1. 和产生式头 $A$ 关联的继承属性
	2. 位于 $X_i$ 左边的 $X_1,X_2,\cdots,X_{i-1}$ 相关的继承属性或综合属性
	3. 和 $X_i$ 本身相关的继承属性或综合属性，但其自身全部属性组成的依赖图无环

eg. 非L属性

![assembly-5-11](assets/assembly-5-11.png)

B.i 依赖 C.c，但产生式中 C 在 B 右边

### 5.2.5 具有受控副作用的语义规则
按照如下方法之一控制 SDD 中的副作用
1. 支持不会对属性求值产生约束的附带副作用：如果按依赖图的任何拓扑顺序进行属性求值，都可产生正确的翻译结果，运行副作用存在
2. 对允许的求值顺序添加约束，使得以任何允许的顺序求值都会产生相同的翻译结果

eg.

![assembly-5-12](assets/assembly-5-12.png)

像 $print(E.val)$ 的语义规则的目的就是执行它们的副作用


## 5.3 语法制导翻译的应用
### 5.3.1 抽象语法树的构造
使用具有适当数量的字段的对象来实现一个语法树的各个结点
每个对象都有一个 $op$ 字段，此外还有如下的其他字段：
1. 叶子结点：构造函数 `Leaf(op, val)` 创建对象，`val` 存放叶子结点的词法值
2. 内部结点：构造函数 `Node(op, c1, c2, ..., ck)`创建对象，k=子结点个数

eg. 

![assembly-5-13](assets/assembly-5-13.png)

![assembly-5-14](assets/assembly-5-14.png)

如果这些规则是在对语法分析树的后序遍历过程中求值的，或者是在自底向上分析过程中和归约动作中一起进行求值的，那么当图5-12中显示的一系列步骤结束时，p5指向构造得到的抽象语法树的根节点

![assembly-5-15](assets/assembly-5-15.png)

如果使用自顶向下语法分析而设计的文法，得到的抽象语法树相同，构造步骤相同
但语法分析树的结构和抽象语法树的结构有极大不同

eg. 图5-13中的L属性定义完成翻译工作与图5-10中S属性定义完成的工作相同

![assembly-5-16](assets/assembly-5-16.png)

![assembly-5-17](assets/assembly-5-17.png)

### 5.3.2 类型的结构
C语言，`int[2][3]` 可读作：由2个数组组成的数组，子数组中有3个整数
相应的类型表达式 $array(2,array(3,integer))$ 可由下图表示

![assembly-5-18](assets/assembly-5-18.png)

SDD如下

![assembly-5-19](assets/assembly-5-19.png)

T：生成一个基本类型或一个数组类型
B：生成基本类型 int 或 float
C：生成由整数序列组成的数组描述分量

B，T：综合属性 t 表示类型
C：继承属性 b 将基本类型沿着树向下传播，综合属性 t 收集最终得到的结果

![assembly-5-20](assets/assembly-5-20.png)